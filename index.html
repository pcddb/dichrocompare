<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <title>DichroCompare</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" href="bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <link href="nouislider.min.css" rel="stylesheet">

        <script src="plotly-latest.min.js"></script>
        <script src="sg_bundle.js"></script>
        <script src="sgg_bundle.js"></script>
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
        <script src="popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
        <script src="bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
        <script src='math.min.js'></script>
        <script src='chroma.min.js'></script>
        <script src='jstat.min.js'></script>
        <script src="nouislider.min.js"></script>
        <script src="wNumb.js"></script>

        
        <script src="html2pdf.bundle.min.js"></script>


        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/pdfmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.68/vfs_fonts.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script> -->
        <!-- <script src="https://cdn.jsdelivr.net/npm/ml-savitzky-golay-generalized@2.0.2/lib/index.min.js"></script> -->
        

        <style>
        
        #section-to-print{
            font-size: 0.7em;
        }
        #pgBrk {
            page-break-after: always;
            
        }
        @media print {
            @page {
            size: auto portrait;  
            
            }
            
            #pgBrk {
            page-break-after: always;
            width: 300mm;
            height:300mm;
            margin: 20mm;
            }
            .modebar{
                display:none;
            }
            .notPrinted{
                display:none;
            }
            #noprint {
                display: none;
            }
            
            #section-to-print {
                
                width: 279mm;
                
                display: block;
                position: absolute;
                left: 0;
                top: 0;
                -webkit-print-color-adjust: exact !important;   /* Chrome, Safari */
                color-adjust: exact !important; /* Firefox */
                font-size: 1rem;
            }
            h4 {
                font-size:1.1rem;
            }
            .col-6 .col-7 .col-8 .col-5 .col-4{
                padding:10px;
            }
        }

        sup  {
            position: inherit;
            vertical-align: super;
        }
        

        div.plotly-notifier {
        visibility: hidden;
        }

        .noUi-marker-horizontal.noUi-marker-large {

            height: 10px;
            margin-left: 1px;

        }

        .noUi-value {
            position: absolute;
            white-space: nowrap;
            text-align: center;
            font-size: small;
        }
        
        tr.selected {
            background-color: rgb(155, 155, 155);
            color: #FFF;
        }
        
        .card-header {
            padding:1px 1px 1px 1px;
            
        }
        
        .btn-secondary {
            font-weight: 700;
            color: white;
            background-color: #365f92;
            border-color: #365f93;
            padding: 1px 3px 1px 3px;
            
            text-align: left;
        }
        .noUi-horizontal .noUi-handle {
        width: 10px;
        height: 28px;
        top: -6px;
        }
        html:not([dir=rtl]) .noUi-horizontal .noUi-handle {
            right: -7px;
            left: auto;
        }
        .noUi-handle:after, .noUi-handle:before {
            display: none;
        }
        .noUi-handle:after, .noUi-handle:before {
            display: none;
        }
        .lineplot {
            width:500px;
            height:400px;
            padding:2px;
            
        }
        .lineplotOL {
            width:500px;
            height:50px;
            padding:2px;
            
        }
        .heatmap {
            width:500px;
            height:500px;
            padding:2px;
            float:right;
            
        }
        .inputfile {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position:absolute;
            z-index: -1;
            
        }
        .inputfile + label {
            font-size: 1em;
            font-weight: 700;
            color: white;
            background-color: rgb(180, 22, 22);
            display: inline-block;
            padding:2px;
            border-radius: 12px;
            border:none;
        }
        

        .inputfile:active + label,
        .inputfile + label:hover {
            background-color: red;
        }
        .dc_logo{
            
            height:118px;
            width:354px
        }
        .dc_logo_div{
            text-align: center;
        }
        hr {
            color: #dadddd;
            background-color: #dadddd;
        }
        .dot {
        
        height: 50px;
        width: 50px;
        background-color: #bbb;
        border-radius: 50%;
        display: inline-block;
        
        }
        .container-fluid {
        /* min-width: 1350px;
        max-width: 1350px; */
        width:1300px;
        }
        .tooltip-inner {
            max-width: 350px;
            /* If max-width does not work, try using width instead */
            width: 350px; 
        }
        </style>
    </head>
    <body>
        <!-- No JS message here -->
        <noscript>
            <div style="background-color: white;height: 150vh;width:100vw;position:absolute;z-index:1000">
                <img class="dc_logo" src="Dichrocomp.jpg">
                <br>
                <h1>This site requires JavaScript to run - please enable this to use the site</h1>
            </div>
        </noscript>
        <div id="loadingImg" style="height:100%;width:100%;position:absolute">
            <h1 style="position:absolute;z-index:100;margin:0;top:50%;left:50%;transform: translate(-50%, -50%);">Please Wait...</h1>
        </div>
        
        <!-- <button type="button" class="btn btn-primary" data-toggle="modal" data-target="#Modal">
                Launch demo modal
                </button> -->
                
                <!-- Modal -->
                <div class="modal fade" id="Modal" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="ModalLabel">Batch Details</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <h6>Please specify a name for the batch (maximum 20 characters).</h6>
                        <label for="batchNameBox">Batch Name:</label>
                        <input type="text" id="batchNameBox">
                        
                        <h6>Please select units for input data, or select .DCS/.DCF if uploading a session or batch file.</h6>
                        <h6>DichroCompare will convert your input to delta epsilon for comparison.</h6>
                        <input type="radio" id="dcsdcf" name="units" value="dcsdcf" >
                        <label for="dcsdcf">DCS/DCF File</label>
                        <br>
                        <input type="radio" id="unit-de" name="units" value="unit-de" checked >
                        <label for="unit-de">dE</label>
                        <br>
                        <input type="radio" id="unit-mre" name="units" value="unit-mre" >
                        <label for="unit-mre">M.R.E.</label>
                        <br>
                        <input type="radio" id="unit-mach" name="units" value="unit-mach" >
                        <label for="unit-mach">Machine Units</label>
                        <br>
                        <input type="number" id="conc" value="conc" step="0.00001">
                        <label for="conc">Concentration (mg/ml)</label>
                        <br>
                        <input type="number" id="pathl" value="pathl" step="0.00001">
                        <label for="pathl">Pathlength (cm)</label>
                        <br>
                        <input type="number" id="mrw" value="mrw" step="0.00001">
                        <label for="mrw">Mean Residue Weight (Da)</label>
                        <br>
                        
                    </div>
                    <div class="modal-footer" style="display:block">
                        
                        <input type="file" id="bufferinput" multiple title=" " class='inputfile'>
                        <label for="bufferinput">&nbspAdd&nbspBuffer&nbspFiles&nbsp(Optional)&nbsp</label>
                        <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The buffer files you add will be converted to the appropriate units (if applicable), averaged then subtracted  from all spectra in the batch upon upload.">i</span>   
                        <span id="bufferNumber" style="padding-left:100px"><small>None</small></span>
                        
                    </div>
                    <div class="modal-footer" style="display:block">
                        
                        
                        <input type="file" id="fileinput" multiple title=" " class='inputfile'>
                        <label for="fileinput">&nbspSelect&nbspFiles&nbspAnd&nbspRun&nbsp</label>
                    </div>
                    </div>
                </div>
                </div>
    <div id="noprint">
        <div class="container-fluid" >
            
            <!--[if lt IE 7]>
                <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
            <![endif]-->
            <div class="dc_logo_div">
                <img class="dc_logo" src="Dichrocomp.jpg">
                <br>
                <a href="index.html" target="_blank">Home</a> | <a href="help.html" target="_blank">Help</a>
            </div>
           
            <!-- <div class="accordion" id="accordionExample"> -->
            
                <div class="card">
                    <div class="card-header" id="headingOne">
                    <h5 class="mb-0">
                        <button class="btn btn-secondary" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                        Input Data
                        </button>
                        
                    </h5>
                    </div>
                    
                    <div id="collapseOne" class="collapse show" aria-labelledby="headingOne">
                    <div class="card-body">
                        <table style="width:100%">
                            <tbody>
                                <tr>
                                    <td style="text-align: left;width:10%">
                                    <button id="resetButton" class="btn btn-danger" type="button">
                                        New Run
                                    </button>
                                    </td>
                                    <td style="text-align: left;width:20%">
                                        <button  type="button" class="btn btn-primary" onclick="$('#nameModal').modal('show')">Change Run Name</button>
                                    </td>
                                    <td style="text-align: left;vertical-align: bottom;width:35%">
                                        <h6>Run Name:&nbsp <i><span id="currentRunName"></span></i></h6>
                                    </td>
                                    <td style="text-align: left;vertical-align: bottom;width:35%">
                                        <h6>DCS File:&nbsp <i><span id="currentDCSName">None</span></i></h6>
                                    </td>
                                    
                                </tr>
                            </tbody>
                        </table>
                            
                        <hr>
                        <div class="row" style="height:410px">
                                
                            <div class="col-4">
                                
                                <div id="filelist" style="overflow-y:scroll; height:380px; width:100%"></div>
                                
                                
                                <!-- <input type="file" id="fileinput" multiple title=" " class='inputfile'/>
                                <label for="fileinput">&nbspAdd&nbspBatch&nbsp</label> -->
                                <button type="button" class="btn btn-danger" data-toggle="modal" data-target="#Modal">
                                Add Batch
                                </button>
                                &nbsp&nbsp&nbsp&nbsp
                                <button style="padding-left: 20px"  id="downloadSession" class="btn btn-danger""/>Download Session File</button>
                                <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The 'Download Session File' button will allow you download a .DCS file that contains the data for ALL batches in the analysis as well as all the options you have selected e.g. Whether scaling is on, the temperature range, the wavelength range, the reference set selection.">i</span>   
                            </div>
                            <div class="col-8" id="summary" style="border-left: 1px solid #c8caca;display:none">
                                <div  class="row" >
                                    <div class="col">
                                        <div id='batchFileListTitle'></div>
                                        
                                    </div>
                                </div>
                                <div class="row">
                                    <div class='col-3'>
                                            <b><h6>Files:</h6></b>
                                            <div id='batchFileList' style="overflow-y:scroll; height:300px; width:100%; display:none;"></div>
                                    </div>
                                    <div class="col-9">
                                        
                                                <ul class="nav nav-tabs" id="myTab2" role="tablist">
                                                    <li class="nav-item">
                                                        <a class="nav-link active" id="noise-tab" data-toggle="tab" href="#noise" role="tab" aria-controls="noise" aria-selected="true">Noise Estimation</a>
                                                    </li>
                                                    <li class="nav-item">
                                                        <a class="nav-link" id="outliers-tab" data-toggle="tab" href="#outliers" role="tab" aria-controls="outliers" aria-selected="false">Outliers</a>
                                                    </li>
                                                    <li class="nav-item">
                                                            <a class="nav-link" id="buffer-tab" data-toggle="tab" href="#buffer" role="tab" aria-controls="buffer" aria-selected="false">Buffer</a>
                                                    </li>
                                                </ul>
                                                <div class="tab-content" id="myTabContent">
                                                    <div class="tab-pane fade show active" id="noise" role="tabpanel" aria-labelledby="noise-tab">
                                                        <div class="row">
                                                            <div class="col-8">
                                                                <div style="display:none">
                                                                <div id="plotly-divHmTrend" style="float:right;display: none"></div>
                                                                </div>
                                                                
                                                                <div id="plotly-divRaw" style="float:right"></div>
                                                                
                                                            </div>
                                                            <div class="col-4">
                                                                <div style="display:none">
                                                                <!-- <div id="plotly-divHmTrend" style="float:right;display: none"></div> -->
                                                                </div>
                                                                <h7>Noise Estimation:</h7>
                                                                <div class="row">
                                                                    <div class="col"><h7><span style="height:50px;width:50px;display:inline-flex;align-items:center" id="noise-pc"></span></h7></div>
                                                                    <div class="col"><span class="dot" id="noiseBall"></span></div>
                                                                </div>
                                                                <h7>Data Used:</h7>
                                                                <div class="row">
                                                                    <div class="col"><h7><span style="height:50px;width:50px;display:inline-flex;align-items:center" id="data-pc"></span></h7></div>
                                                                    <div class="col"><span class="dot" id="dataBall"></span></div>
                                                                </div>
                                                                    
                                                                
                                                            </div>  
                                                        </div>

                                                    </div>
                                                    <div class="tab-pane fade" id="outliers" role="tabpanel" aria-labelledby="outliers-tab">
                                                        <div class="row">
                                                            <div class="col-8">
                                                                
                                                                
                                                                <div id='plotly-divOutliers' style="float:right"></div>
                                                                
                                                            </div>
                                                            <div class="col-4" >
                                                                
                                                                <h7>% of data points</h7>
                                                                <div style="overflow-y:scroll; height:280px;">
                                                                    <table id="outlier-table" ></table>
                                                                </div>
                                                                
                                                                
                                                            </div>  
                                                        </div>  
                                                    </div>
                                                    <div class="tab-pane fade" id="buffer" role="tabpanel" aria-labelledby="buffer-tab">
                                                            <div class="row">
                                                                <div class="col-8">
                                                                    
                                                                    
                                                                    <div id='plotly-divBuffer' style="float:right"></div>
                                                                    
                                                                </div>
                                                                <div class="col-4" >
                                                                    <h7>Buffer Files:</h7>
                                                                        
                                                                    <div id='bufferFileList' style="overflow-y:scroll; height:280px; width:100%; display:none;"></div>
                                                                    
                                                                    
                                                                </div>  
                                                            </div>
                                                    </div>
                                                </div>
                                        
                                    </div>
                                    
                                </div>
                                
                            </div>
                        </div>
                        
                    </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header" id="headingTwo">
                        <h5 class="mb-0">
                        <button class="btn btn-secondary collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                            Options
                        </button>
                        </h5>
                    </div>
                    <div id="collapseTwo" class="collapse show" aria-labelledby="headingTwo">
                        <div class="card-body">
                            <div class="row" style="">
                                <div class="col-3">
                                    <div style="min-width:500px">
                                        
                                        
                                        <span style="padding:0px 0px 0px 0px;">Scaling Factors:</span>
                                        <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="If scaling is on, the list of scale factors used for each batch will be displayed below.">i</span>    
                                        <div id="scaleList" style="overflow-y:scroll; height:80px; width:185px;">
                                            
                                        </div>
                                        <br>
                                        
                                    </div>
                                </div>
                                <div class="col-4">
                                    <input class="" type="checkbox" value="" id="scale">
                                    <label class="" for="scale">
                                        Scale data?
                                    </label>
                                    <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Batch mean spectra will be scaled by RMSD minimisation to the largest mean batch spectra.">i</span>    
                                    <br>
                                    <input class="" type="checkbox" value="" id="zeroData">
                                    <label class="" for="zeroData">
                                        Zero @ 
                                    </label>
                                    <input type="number" value="250" id="zeroWL1" style="width:80px">
                                    to
                                    <input type="number" value="250" id="zeroWL2" style="width:80px">
                                    nm&nbsp
                                    <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Choose whether to zero data at chosen wavelength.">i</span>    
                                    <table style="display:none">
                                        <tr>
                                            <td   style="vertical-align:top;padding: 10px 10px 0 0;">
                                                <h6>Deviation Threshold: </h6>
                                            </td>
                                            <td>
                                                <input type="number" step="0.05" min="0" max="10000" name="devThresh" id="devThresh">
                                                <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Threshold used in calculation of per-wavelength deviations.">i</span>
                                                <br>
                                                <br>
                                                <br>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <h6  style="float:left;">Conf. Level:&nbsp&nbsp&nbsp</h6>
                                            </td>
                                            <td>
                                                <div id="alpha-slider" style="float:left;width:170px"></div>
                                                &nbsp&nbsp&nbsp<span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Select % for calculation of per-wavelength confidence intervals used when determining if a batch means are significantly different. Higher % mean you can be more certain they is a difference if they don't overlap.">i</span>
                                            </td>
                                        </tr>
                                    </table>
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                </div>
                                <div class="col-5">
                                    Select wavelength range (nm): 
                                    <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Select a wavelength range to analyse. Tip - for the best analysis, slide the right handle to remove 'zero signal' data, making sure the 'Data Used' value above stays >99%. Then use the left handle to remove noisy wavelengths from the analysis for each batch you add, so the 'Noise Estimation' reaches 0%.">i</span>
                                    <br>
                                    <br>
                                    <br>
                                    <div id="wl-slider" style="width:400px"></div>
                                </div>
                            </div>
                            
                            
                            
                            
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header" id="headingThree">
                        <h5 class="mb-0">
                        <button class="btn btn-secondary collapsed"  type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">
                            Results
                        </button>
                        </h5>
                    </div>
                    <div id="collapseThree" class="collapse" aria-labelledby="headingThree">
                        <div class="card-body">
                            
                            <ul class="nav nav-tabs" id="myTab3" role="tablist">
                                <li class="nav-item">
                                    <a class="nav-link active" id="simple-tab" data-toggle="tab" href="#simple" role="tab" aria-controls="simple" aria-selected="true">Summary</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" id="detailed-tab" data-toggle="tab" href="#detailed" role="tab" aria-controls="detailed" aria-selected="false">Detailed</a>
                                </li>
                                
                                <div style="float:right;padding-left:600px; padding-right:20px">
                                    
                                    <input id="qcmode-1" type="checkbox" name="refMode" value="1" checked="true" > QC Mode 
                                    <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Switching on QC mode allows for a reference set of batches to be defined. In QC mode, statistics will be calculated for a batch vs ONLY the batches in the reference set. Reference set batches are indicated by blue text. Non-reference set batches (test batches) will be coloured black if their score falls within 3 sigma of the reference set average score, red if they fall outside this region. The 3 sigma lower bound of acceptance and the 'Test score' (the average score of all test batches vs the reference set) will replace 'Overall Score'. ">i</span>
                                    <button style="margin-left:50px" type="button" class="btn btn-danger" onclick="printReportold()">PDF Report</button>
                                    
                                </div>
                                
                            </ul>
                            <div class="tab-content" id="simpleTabContent">
                                <div class="tab-pane fade show active" id="simple" role="tabpanel" aria-labelledby="simple-tab">
                                    <br>
                                    <div class="row">
                                        <div class="col-6">
                                            <h6>Mean Spectra <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Mean CD spectra of each batch. Zooming or panning this plot using the controls will update the Asolute Difference Spectra plot as well.">i</span>    </h6>
                                            <div  id="plotly-div-S"></div>
                                            
                                        </div>
                                        <div class="col-6" >
                                            <br>
                                            <br>
                                            <div class="row">
                                                <div class="col-8">
                                                    <div id="refSetOptionsSimp" style="overflow-y:auto;height:350px; width:100%;padding:0px 0px 0px 0px;border: 1px solid #c8caca;"></div>
                                                </div>
                                                <div class="col-4">
                                                    <div style="width:100%;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                        <h4 id="passcountSimp" style="font-size: 3rem;">
                                                            ---%&nbsp
                                                        </h4>
                                                        <h6>SAME</h6>
                                                    </div>
                                                    <div style="width:100%;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                        <h4 id="flagcountSimp" style="font-size: 3rem;color:rgb(249, 8, 234)">
                                                            ---%&nbsp
                                                        </h4>
                                                        <h6 style="color:rgb(249, 8, 234)">FLAG</h6>
                                                    </div>
                                                    <div style="width:100%;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                        <h4 id="failcountSimp" style="font-size: 3rem;color:red">
                                                            ---%&nbsp
                                                        </h4>
                                                        <h6 style="color:red">DIFFERENT</h6>
                                                    </div>
                                                    
                                                </div>
                                            </div>
                                            

                                            <br>
                                            
                                            
                                        </div>
                                    </div>
                                    <hr>
                                    <div class="row">
                                        <div class="col-9" style="padding-top:15px;text-align:center">
                                            <h6>Equivalence test plot <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Equivalence margin plot of the 90% CI for the mean differences for each test batch against the reference set, with the 1.5sigma margin shown.">i</span>    </h6>
                                            <div style="float:left">Equivalence Limit Multiplier:&nbsp<span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Sets/displays the multiplier applied to the reference set standard deviation to define the equivalence limit. In QC mode this is automatically calculated from your data. In non-QC mode, this can be set manually. It is bounded to values between 1.5 and 3.0.">i</span></div>
                                            
                                            <div id="equiv-slider" style="float:left;width:100px;margin-left:20px"></div>
                                            <div style="float:left;color:#dc3545;margin-left:20px" class="equiv-message"></div>
                                            <br>
                                            <div id='plotly-divsig-S' style="display: inline-block;"></div>

                                        </div>
                                        <div class="col-3" style="padding-top:15px;text-align:center">
                                            <h6>Data Quality<span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The uppper bounds of the confidence interval resulting from pairwise comparison of the difference between batch mean standard errors (SE) is shown for the batch selected in the Summary table vs all other batches (indicated by trace colour). If the lower bound is >0, there is a significant difference between means at that wavelength.">i</span>    </h6>
                                            <br>
                                            <div id='plotly-divsnr-S' style="display: inline-block;text-align:center"></div>
                                            
                                            
                                        </div>
                                        
                                    </div>
                                </div>
                            
                                <div class="tab-pane fade" id="detailed" role="tabpanel" aria-labelledby="detailed-tab">
                                    <br>
                                    <div class="row">
                                        <div class="col-6"  style="padding-top:15px;text-align:center">
                                            <h6>Mean Spectra <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Mean CD spectra of each batch. Zooming or panning this plot using the controls will update the Asolute Difference Spectra plot as well.">i</span>    </h6>
                                            <div  id="plotly-div"></div>
                                            <div  id="plotly-div2"></div>
                                        </div>
                                        <div class="col-6"  style="padding-top:15px;text-align:center">
                                            <!-- <h6>Absolute Difference Spectra <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The lower bounds of the confidence interval resulting from pairwise comparison of the difference between batch means is shown for the batch selected in the Summary table vs all other batches (indicated by trace colour). If the lower bound is >0, there is a significant difference between means at that wavelength.">i</span>    </h6> -->
                                            
                                            <h6>Pairwise Significant Spectral Differences (SSD) <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The Spectral Difference spectral difference scores for all possible pairwise batch comparisons.">i</span></h6>
                                            <center>
                                            <div id="plotly-divHm"></div>
                                            </center>
                                            
                                        </div>
                                       
                                    </div>
                                    <hr>
                                    <div class="row">
                                        
                                        <div class="col-9" id="summ-con" style="padding-left:50px">
                                            <div id="summary1" class="row" style="height:330px">
                                                <div class="col" style="padding:15px;">
                                                    
                                                    
                                                    <div id="refSetOptions" style="overflow-y:auto;height:300px; width:100%;border: 1px solid #c8caca;padding:0px"></div>
                                                    <br>
                                                
                                                </div>
                                            </div>
                                            <div  id="summary2"  class="row" style="display: none;">
                                                <div class="col-7">
                                                    
                                                    <div id="refSetFacts" style="display:none"></div>
                                                    <div class="row" id="QC1" style="display: none">
                                                        <div class="col-9" style="display: table-cell; vertical-align: bottom;">
                                                            <h5>95% Acceptance:</h5>
                                                            <table style="width: 300px">
                                                                <tr id="overallScoreSNR"><td>XXXX</td></tr>
                                                                <tr id="overallScoreRef"><td>XXXX</td></tr>
                                                            </table>
                                                        </div>
                                                        <div class="col-3" style="display: table-cell; vertical-align: bottom;padding:0;"><span class="dot" id="scoreBallRef"></span></div>
                                                    </div>
                                                    <br><br>
                                                </div>
                                                <div class="col-1"></div>
                                                <div class="col-4">
                                                    <div class="row" id="nonQC">
                                                        <div class="col-9" style="display: table-cell; vertical-align: bottom;"><h4>DCOMP ALL: </h4><h4><span id="overallScore">XXXX</span>/<small>1000</small></h4></div>
                                                        <div class="col-3" style="display: table-cell; vertical-align: bottom;padding:0;"><span class="dot" id="scoreBall"></span></div>
                                                    </div>
                                                    <div class="row"  id="QC2" style="display: none">
                                                        
                                                        <div class="col-9" style="display: table-cell; vertical-align: bottom;"><h4>DCOMP TEST: </h4><h4><span id="overallScoreVs">XXXX</span>/<small>1000</small></h4></div>
                                                        <div class="col-3" style="display: table-cell; vertical-align: bottom;padding:0;"><span class="dot" id="scoreBallVs"></span></div>
                                                    </div>
                                                </div>
                                                
                                            </div>
                                        </div>
                                        <div class="col-3" id="sig-con" style="padding-top:15px;text-align:center">
                                            <div style="width:250px;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                <h4 id="passcount" style="font-size: 3rem;">
                                                    ---%&nbsp
                                                </h4>
                                                <h6>SAME</h6>
                                            </div>
                                            <h6 style="display:none" id="score">NA% difference<br> <small><small>Add data above</small></small></h6>
                                            <div style="width:250px;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                <h4 id="flagcount" style="font-size: 3rem;color:rgb(249, 8, 234)">
                                                    ---%&nbsp
                                                </h4>
                                                <h6 style="color:rgb(249, 8, 234)">FLAG</h6>
                                            </div>
                                            <div style="width:250px;height:30%;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                                <h4 id="failcount" style="font-size: 3rem;color:red">
                                                    ---%&nbsp
                                                </h4>
                                                <h6 style="color:red">DIFFERENT</h6>
                                            </div>
                                            
                                        </div>
                                        
                                        
                                    </div>
                                    <hr>
                                    <div class="row">
                                        <div class="col-9" style="padding-top:15px;text-align:center">
                                            <h6>Equivalence test plot <span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Equivalence margin plot of the 90% CI for the mean differences for each test batch against the reference set, with the 1.5sigma margin shown.">i</span>    </h6>
                                            <div style="float:left">Equivalence Limit Multiplier:&nbsp<span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="Sets/displays the multiplier applied to the reference set standard deviation to define the equivalence limit. In QC mode this is automatically calculated from your data. In non-QC mode, this can be set manually. It is bounded to values between 1.5 and 3.0.">i</span></div>
                                            
                                            <div id="equiv_det-slider" style="float:left;width:100px;margin-left:20px"></div>
                                            <div style="float:left;color:#dc3545;margin-left:20px" class="equiv-message"></div>
                                            <br>
                                            <div id='plotly-divsig' style="display: inline-block;"></div>

                                        </div>
                                        <div class="col-3" style="padding-top:15px;text-align:center">
                                            <h6>Data Quality<span class="badge badge-pill badge-secondary" data-toggle="tooltip" title="The uppper bounds of the confidence interval resulting from pairwise comparison of the difference between batch mean standard errors (SE) is shown for the batch selected in the Summary table vs all other batches (indicated by trace colour). If the lower bound is >0, there is a significant difference between means at that wavelength.">i</span>    </h6>
                                            <br>
                                            <div id='plotly-divsnr' style="display: inline-block;text-align:center"></div>
                                            
                                            
                                        </div>
                                        
                                    </div>
                                    
                                    
                                </div>
                            </div>
                            
                        </div>
                    </div>
                </div>
                
                
            
            
        </div>
        
    <br>
    <footer class="py-4 bg-light text-black-50">
        <div class="container text-center">
            <span id="year"></span> Dr Elliot Drew and Dr R.W. Janes, <i>Queen Mary, University of London</i>
        </div>
    </footer>
    </div>

    <div id="section-to-print">
        
        
    </div>
    <div class="modal" tabindex="-1" role="dialog" id="printModalError">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Sorry!</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <p>You need to either upload more batches or define some non-reference set test batches to print the analysis report.</p>
            </div>
            <div class="modal-footer">
              
              <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
          </div>
        </div>
    </div>

    <div class="modal" tabindex="-1" role="dialog" id="nameModal">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Run Name</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <p>Provide a name for this analysis to identify it (max length 35 characters).</p>
              <p id="saveNameError" style="color:red;"></p>
              <label for="runName">Name: </label>
              <input type="text" id="runName" name="runName" maxlength=35>
              
            </div>
            <div class="modal-footer">
              
              <button id="saveNameButton" type="button" class="btn btn-secondary">Done</button>
              
            </div>
          </div>
        </div>
    </div>

    <div class="modal" tabindex="-1" role="dialog" id="bnameModal">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Batch Name</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <p>Provide a name for the batch to identify it (max length 20 characters).</p>
              <p id="batchNameError" style="color:red;"></p>
              <label for="batchNameChange">Name: </label>
              <input type="text" id="batchNameChange" name="batchNameChange" maxlength=20>
              
            </div>
            <div class="modal-footer">
              
              <button id="saveBatchNameButton" type="button" class="btn btn-secondary">Done</button>
              
            </div>
          </div>
        </div>
    </div>

    <div class="modal" tabindex="-1" role="dialog" id="resetModal">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            
            <div class="modal-body">
              <p>Are you sure you want to start a new run? All data will be removed.</p>
              <p>Click Yes (save .DCS) to save your current session as a .DCS file before starting the new run.</p>
              
              
            </div>
            <div class="modal-footer" style="display:block">
                <div style="text-align: center;">
                <button id="resetButtonYesSave" type="button" class="btn btn-danger" style="margin-right:50px">Yes (save .DCS)</button>
                <button id="resetButtonYes" type="button" class="btn btn-danger" style="margin-right:50px">Yes (don't save)</button>
                <button id="resetButtonNo" type="button" class="btn btn-primary">No</button>
                </div>
            </div>
          </div>
        </div>
    </div>

<script>


document.getElementById("resetButton").addEventListener("click", function(e){
    $('#resetModal').modal('show')
})

document.getElementById("resetButtonYesSave").addEventListener("click", function(e){
    let answer=downloadDCS(batches)
    if(answer){
        location.reload()
    }
    
})

document.getElementById("resetButtonYes").addEventListener("click", function(e){
    
    location.reload()
})
document.getElementById("resetButtonNo").addEventListener("click", function(e){
    $('#resetModal').modal('hide')
    
})

var runname = "None";
document.getElementById("currentRunName").innerHTML=runname
document.getElementById("runName").value=""
document.getElementById("batchNameChange").value=""

document.getElementById("saveNameButton").addEventListener("click", function(e){
    tmp_name=document.getElementById("runName").value
    console.log(tmp_name)
    tmp_name=tmp_name.trim()
    tmp_name=tmp_name.replace(/(<([^>]+)>)/gi, "");
    errorNameP=document.getElementById("saveNameError")
    if(tmp_name!=""){
        runname=tmp_name
        errorNameP.innerHTML=""
        $('#nameModal').modal('hide')
        document.getElementById("currentRunName").innerHTML=runname
        
    }else{
        errorNameP.innerHTML="Name cannot be blank."
    }

    
})

// make sure year in footer is correct
document.getElementById("year").innerHTML=new Date().getFullYear();

document.getElementById("loadingImg").hidden = true;


function SavitzkyGolay(e, t, r = {}) { let { windowSize: o = 9, derivative: n = 0, polynomial: l = 3 } = r; if (o % 2 == 0 || o < 5 || !Number.isInteger(o)) throw new RangeError("Invalid window size (should be odd and at least 5 integer number)"); if (o > e.length) throw new RangeError(`Window size is higher than the data length ${o}>${e.length}`); if (n < 0 || !Number.isInteger(n)) throw new RangeError("Derivative should be a positive integer"); if (l < 1 || !Number.isInteger(l)) throw new RangeError("Polynomial should be a positive integer"); l >= 6 && console.warn("You should not use polynomial grade higher than 5 if you are not sure that your data arises from such a model. Possible polynomial oscillation problems"); let i = Math.floor(o / 2), a = e.length, s = new Array(a), h = fullWeights(o, l, n), u = 0, f = !0; Array.isArray(t) ? f = !1 : u = Math.pow(t, n); for (let r = 0; r < i; r++) { let l = h[i - r - 1], g = h[i + r + 1], y = 0, w = 0; for (let t = 0; t < o; t++)y += l[t] * e[t], w += g[t] * e[a - o + t]; f ? (s[i - r - 1] = y / u, s[a - i + r] = w / u) : (u = getHs(t, i - r - 1, i, n), s[i - r - 1] = y / u, u = getHs(t, a - i + r, i, n), s[a - i + r] = w / u) } let g = h[i]; for (let r = o; r <= a; r++) { let l = 0; for (let t = 0; t < o; t++)l += g[t] * e[t + r - o]; f || (u = getHs(t, r - i - 1, i, n)), s[r - i - 1] = l / u } return s } function getHs(e, t, r, o) { let n = 0, l = 0; for (let o = t - r; o < t + r; o++)o >= 0 && o < e.length - 1 && (n += e[o + 1] - e[o], l++); return Math.pow(n / l, o) } function GramPoly(e, t, r, o) { let n = 0; return n = r > 0 ? (4 * r - 2) / (r * (2 * t - r + 1)) * (e * GramPoly(e, t, r - 1, o) + o * GramPoly(e, t, r - 1, o - 1)) - (r - 1) * (2 * t + r) / (r * (2 * t - r + 1)) * GramPoly(e, t, r - 2, o) : 0 === r && 0 === o ? 1 : 0 } function GenFact(e, t) { let r = 1; if (e >= t) for (let o = e - t + 1; o <= e; o++)r *= o; return r } function Weight(e, t, r, o, n) { let l = 0; for (let i = 0; i <= o; i++)l += (2 * i + 1) * (GenFact(2 * r, i) / GenFact(2 * r + i + 1, i + 1)) * GramPoly(e, r, i, 0) * GramPoly(t, r, i, n); return l } function fullWeights(e, t, r) { let o = new Array(e), n = Math.floor(e / 2); for (let l = -n; l <= n; l++) { o[l + n] = new Array(e); for (let e = -n; e <= n; e++)o[l + n][e + n] = Weight(e, l, n, t, r) } return o }

/* 
*/

function printReport(){
    
    var plotSVG=document.getElementById("plotly-div").childNodes[0].childNodes[0];
    console.log(plotSVG)
    plotSVG.childNodes[0].viewBox="0 0 "+plotSVG.width+" "+plotSVG.height+"" // first svg node in a plotly svg container - add in viewbox shit
    plotSVG=plotSVG.innerHTML;
    plotSVG=plotSVG.split("</svg>")[0]+"</svg>"

    plotSVG=`<svg id="svg-01" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width: 200px; height: 200px;">	<title>HTML5 Logo</title>	<desc>Shaped like a shield with the text 'HTML' above and the numeral '5' prominent on the face of the shield.</desc>	<polygon fill="#e44d26" points="107.644,470.877 74.633,100.62 437.367,100.62 404.321,470.819 255.778,512"></polygon>	<polygon fill="#f16529" points="256,480.523 376.03,447.246 404.27,130.894 256,130.894"></polygon>	<polygon fill="#ebebeb" points="256,268.217 195.91,268.217 191.76,221.716 256,221.716 256,176.305 255.843,176.305 142.132,176.305 143.219,188.488 154.38,313.627 256,313.627"></polygon>	<polygon fill="#ebebeb" points="256,386.153 255.801,386.206 205.227,372.55 201.994,336.333 177.419,336.333 156.409,336.333 162.771,407.634 255.791,433.457 256,433.399"></polygon>	<path d="M 108.382 0 h 23.077 v 22.8 h 21.11 V 0 h 23.078 v 69.044 H 152.57 v -23.12 h -21.11 v 23.12 h -23.077 V 0 Z"></path>	<path d="M 205.994 22.896 h -20.316 V 0 h 63.72 v 22.896 h -20.325 v 46.148 h -23.078 V 22.896 Z"></path>	<path d="M 259.511 0 h 24.063 l 14.802 24.26 L 313.163 0 h 24.072 v 69.044 h -22.982 V 34.822 l -15.877 24.549 h -0.397 l -15.888 -24.549 v 34.222 h -22.58 V 0 Z"></path>	<path d="M 348.72 0 h 23.084 v 46.222 h 32.453 v 22.822 H 348.72 V 0 Z"></path>	<polygon fill="#fff" points="255.843,268.217 255.843,313.627 311.761,313.627 306.49,372.521 255.843,386.191 255.843,433.435 348.937,407.634 349.62,399.962 360.291,280.411 361.399,268.217 349.162,268.217"></polygon>	<polygon fill="#fff" points="255.843,176.305 255.843,204.509 255.843,221.605 255.843,221.716 365.385,221.716 365.385,221.716 365.531,221.716 366.442,211.509 368.511,188.488 369.597,176.305"></polygon></svg>`
    
    var doc = new jspdf.jsPDF()

    doc.setFontSize(40)
    doc.text(35, 25, 'Paranyan loves jsPDF')
    //doc.addImage(imgData, 'JPEG', 15, 40, 180, 160)
    doc.addSvgAsImage(plotSVG, 15, 40, 180, 160, "alias", "NONE", 0)
    doc.save("test.pdf")

}

var opt = {
            margin:       0.5,
            filename:     'myfile.pdf',
            image:        { type: 'jpeg', quality: 0.98 },
            html2canvas:  { scale: 2 },
            jsPDF:        { unit: 'in', format: 'letter', orientation: 'portrait' }
        };

var printTable={};

var passFlagFail=[];

function slugify(str)
{
    str = str.replace(/^\s+|\s+$/g, '');

    // Make the string lowercase
    str = str.toLowerCase();

    // Remove accents, swap  for n, etc
    var from = "a/_,:;";
    var to   = "AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------";
    for (var i=0, l=from.length ; i<l ; i++) {
        str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
    }

    // Remove invalid chars
    str = str.replace(/[^a-z0-9 -]/g, '') 
    // Collapse whitespace and replace by -
    .replace(/\s+/g, '-') 
    // Collapse dashes
    .replace(/-+/g, '-'); 

    return str;
}

function printReportold() {

    opt.filename=slugify(runname)+".pdf"

    
    if(passFlagFail.length!=0){

        
        if (name != null) {

            document.getElementById("section-to-print").innerHTML=
            `<div id="pgBrk">
                <div class="row">
                    <div class="col-6">
                        <img style="width:100%; position:relative; top:50%;transform:translateY(-50%); text-align: center;" src="Dichrocomp.jpg">
                    </div>
                    <div class="col-6" id="print2"></div>
                </div>
                <hr>
                
                    
                    
                
                <h6>Mean batch CD spectra</h6>
                <div id="printCD"></div>
                
                
                <hr>
                <div class="row">
                    <div class="col-9">
                        <h6>Equivalence test</h6>
                        <div id="printEquiv"></div>
                    </div>
                    
                    <div class="col-3">
                        <h6>Data Quality Test</h6>
                        <div id="printQual"></div>
                    </div>
                </div>
            </div>
            <div>
                <div class="row">
                    <div class="col-6">
                        <img style="width:100%; position:relative; top:50%;transform:translateY(-50%); text-align: center;" src="Dichrocomp.jpg">
                    </div>
                    <div class="col-6" id="print3"></div>
                </div>
                <hr>
                <h6>Table of results</h6>
                <div class="row">
                    <div class="col-8">
                        <div id="printSum"></div>    
                    </div>
                    <div class="col-4">
                        <div id="printOverall">
                            <div style="width:250px;height:50px;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                <h6 id="passcountPrint" style="">
                                    ---%&nbsp
                                </h4>
                                <h6 style="font-size:1.1em"">SAME</h6>
                            </div>
                            <h6 style="display:none" id="score">NA% difference<br> <small><small>Add data above</small></small></h6>
                            <div style="width:250px;height:50px;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                <h6 id="flagcountPrint" style="color:rgb(249, 8, 234)">
                                    ---%&nbsp
                                </h4>
                                <h6 style="color:rgb(249, 8, 234); font-size:1.1em">FLAG</h6>
                            </div>
                            <div style="width:250px;height:50px;margin: 0 auto;padding:0% 0% 0% 0%;text-align:center">
                                <h6 id="failcountPrint" style="color:red">
                                    ---%&nbsp
                                </h4>
                                <h6 style="color:red; font-size:1.1em"">DIFFERENT</h6>
                            </div>   
                        </div>
                    </div>
                </div>
                
                
                <hr>
            </div>`

            if (passFlagFail.length > 0) {
                failCount = 0;
                passCount = 0;
                flagCount = 0;
                for (let fff = 0; fff < passFlagFail.length; fff++) {
                    if (passFlagFail[fff] == "fail") {
                        failCount++
                    } else if (passFlagFail[fff] == "pass") {
                        passCount++
                    } else if (passFlagFail[fff] == "flag") {
                        flagCount++
                    }

                }
                document.getElementById("failcountPrint").innerHTML = "" + math.round(failCount / passFlagFail.length * 100) + "%"
                document.getElementById("passcountPrint").innerHTML = "" + math.round(passCount / passFlagFail.length * 100) + "%"
                document.getElementById("flagcountPrint").innerHTML = "" + math.round(flagCount / passFlagFail.length * 100) + "%"
            } else {
                document.getElementById("failcountPrint").innerHTML = "---%"
                document.getElementById("passcountPrint").innerHTML = "---%"
                document.getElementById("flagcountPrint").innerHTML = "---%"
            }


            cdPlot_dest = document.getElementById("printCD")
            equivPlot_dest = document.getElementById("printEquiv")
            print2_dest = document.getElementById("print2")
            print3_dest = document.getElementById("print3")
            summ_dest = document.getElementById("printSum")

            cdPlot = document.getElementById("plotly-div")
            equivPlot = document.getElementById("plotly-divsig")

            

            sum1 = document.getElementById("refSetOptions")
            sum2 = document.getElementById("summary2")



            cdPlot_parent = cdPlot.parentNode;
            equivPlot_parent = equivPlot.parentNode;

            sum1_parent = sum1.parentNode;
            sum2_parent = sum2.parentNode;

            /* cdPlot_dest.appendChild(cdPlot)
            equivPlot_dest.appendChild(equivPlot) */

            
            
            pTable = document.createElement("table")
            pTable.setAttribute("style", "width:100%;")
            pTHead = document.createElement("thead")
            
            
            pTHead.innerHTML += "<tr><th style='text-align:left'>Batch Name</th><th style='text-align:right'>Within Batch Av. SE. ()</th><th style='text-align:right'>Av. Spectral Diff. ()</th><th style='text-align:right'>SAME?</th></tr>"
            

            pTable.appendChild(pTHead)
            pTBody = document.createElement("tbody")

            for(i=0;i<printTable.length;i++){
                pTr = document.createElement("tr")
                for(j=0;j<4;j++){
                    pTd = document.createElement("td")
                    pTd.innerHTML=printTable[i][j]
                    pTd.style.color=printTable[i].color
                    if(j!=0){
                        pTd.style.textAlign="right"
                    }else{
                        pTd.style.textAlign="left"
                    }
                    
                    pTr.appendChild(pTd)
                }
                pTBody.appendChild(pTr)
            }
            pTable.appendChild(pTBody)
            
            summ_dest.appendChild(pTable)

            layoutsig_print = JSON.parse(JSON.stringify(layoutsig))
            layoutsnr_print = JSON.parse(JSON.stringify(layoutsnr))
            layout_print = JSON.parse(JSON.stringify(layout))

            layoutsig_print.width=550
            layoutsig_print.height=300

            layoutsnr_print.width=200
            layoutsnr_print.height=300

            layout_print.width=750
            layout_print.height=300

            layout_print.margin={t: 50, b: 50, r: 50, l: 50 }
            layoutsig_print.margin={t: 50, b: 50, r: 50, l: 50 }
            layoutsnr_print.margin={t: 50, b: 50, r: 50, l: 50 }

            layout_print.xaxis.showticklabels=true

            layout_print.xaxis.tickfont={ size: 10 }
            layout_print.yaxis.tickfont={ size: 10 }

            layoutsig_print.xaxis.tickfont={ size: 10 }
            layoutsig_print.yaxis.tickfont={ size: 10 }

            layoutsnr_print.yaxis.tickfont={ size: 10 }

            layout_print.xaxis.title={ text: "Wavelength (nm)", font:{size:10} }
            layout_print.yaxis.title={ text: "CD (dE)", font:{size:10} }

            layoutsig_print.xaxis.title={ text: "Difference Between means (dE)", font:{size:10} }
            layoutsig_print.yaxis.title={ text: "Batch Name", font:{size:10} }

            layoutsnr_print.yaxis.title={ text: "Av. Standard Error (dE)", font:{size:10} }


            Plotly.react('printEquiv', data_sig, layoutsig_print, {displayModeBar:false});

            Plotly.react('printQual', data_snr, layoutsnr_print, {displayModeBar:false});

            Plotly.react('printCD', data_l, layout_print, {displayModeBar:false});

            
            printText=[0,0]
            for(i=0;i<2;i++){
                printText[i] = "<table style='width:100%'><tbody>"
                printText[i] += "<tr><td><b>Run Name</b></td><td style='text-align:right;'>" + runname + "</td></tr>"
                printText[i] += "<tr><td><b>Date</b></td><td style='text-align:right;'>" + Date().split(" ").slice(1, 5).join(" ") + "</td></tr>"
                printText[i] += "<tr><td><b>Number of Batches</b></td><td style='text-align:right;'>" + Object.keys(batches).length + "</td></tr>"
                
                if (qcmode) {
                    printText[i] += "<tr><td><b>QC mode?</b></td><td style='text-align:right;'>Yes</td></tr>"
                } else {
                    printText[i] += "<tr><td><b>QC mode?</b></td><td style='text-align:right;'>No</td></tr>"
                }
                
                printText[i] += "<tr><td><b>WL range</b></td><td style='text-align:right;'>" + wl_range[0] + "-" + wl_range[1] + " nm</td></tr>"
                

                if (scale_bool == "true") {
                    printText[i] += "<tr><td><b>Scaling?</b></td><td style='text-align:right;'>Yes</td></tr>"
                } else {
                    printText[i] += "<tr><td><b>Scaling?</b></td><td style='text-align:right;'>No</td></tr>"
                }
                if (zero_bool) {
                    printText[i] += "<tr><td><b>Zeroed?</b></td><td style='text-align:right;'>" + zero_wl1 + "-" + zero_wl2 + " nm</td></tr>"
                } else {
                    printText[i] += "<tr><td><b>Zeroed?</b></td><td style='text-align:right;'>No</td></tr>"
                }

                printText[i] += "<tr><td><b>Page</b></td><td style='text-align:right;'>"+(i+1)+" of 2</td></tr>"

                printText[i]+="</tbody></table>"
            }
            
            

            print2_dest.innerHTML = printText[0]
            
            print3_dest.innerHTML = printText[1]
            
            
            

            var printEl=document.getElementById("section-to-print")
            
            ///printEl.style.display="block"
            html2pdf(printEl, opt).then(function(){
                //printEl.style.display="none"


                /* cdPlot_parent.appendChild(cdPlot)
                equivPlot_parent.appendChild(equivPlot) */
                
                

                cdPlot_dest.innerHTML=""
                equivPlot_dest.innerHTML=""
                print2_dest.innerHTML=""
                summ_dest.innerHTML=""
                printEl.innerHTML=""
            })

        }
    }else{
        $('#printModalError').modal('show')
    }
}

$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})


/* 
NEED:

Function to read data from uploaded file and add to data array. -> adding batches.

Function to calculate Standard error and Confidence intervals with a given Confidence


 */




/** * @(#)qnorm.js * * Copyright (c) 2000 by Sundar Dorai-Raj
 * * @author Sundar Dorai-Raj
 * * Email: sdoraira@vt.edu
 * * This program is free software; you can redistribute it and/or
 * * modify it under the terms of the GNU General Public License 
 * * as published by the Free Software Foundation; either version 2 
 * * of the License, or (at your option) any later version, 
 * * provided that any use properly credits the author. 
 * * This program is distributed in the hope that it will be useful,
 * * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * * GNU General Public License for more details at http://www.gnu.org
 * * */

var qnorm = function (p) {




    p = parseFloat(p);
    var split = 0.42;

    var a0 = 2.50662823884;
    var a1 = -18.61500062529;
    var a2 = 41.39119773534;
    var a3 = -25.44106049637;
    var b1 = -8.47351093090;
    var b2 = 23.08336743743;
    var b3 = -21.06224101826;
    var b4 = 3.13082909833;
    var c0 = -2.78718931138;
    var c1 = -2.29796479134;
    var c2 = 4.85014127135;
    var c3 = 2.32121276858;
    var d1 = 3.54388924762;
    var d2 = 1.63706781897;

    var q = p - 0.5;

    var r, ppnd;

    if (Math.abs(q) <= split) {
        r = q * q;
        ppnd = q * (((a3 * r + a2) * r + a1) * r + a0) / ((((b4 * r + b3) * r + b2) * r + b1) * r + 1);
    } else {
        r = p;
        if (q > 0) r = 1 - p;
        if (r > 0) {
            r = Math.sqrt(-Math.log(r));
            ppnd = (((c3 * r + c2) * r + c1) * r + c0) / ((d2 * r + d1) * r + 1);
            if (q < 0) ppnd = -ppnd;
        }
        else {
            ppnd = 0;
        }
    }

    return ppnd;
}

function download(filename, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}

function downloadDCF(batch) {
    let name = prompt("Please enter a name for the batch file download:", "batch");
    if (name != null) {
        text = ""

        files = batch.fileList
        for (p = 0; p < files.length; p++) {
            text += ">" + files[p] + "\n"
            cd = batch.files[files[p]].cd
            wl = batch.files[files[p]].wl
            for (pp = 0; pp < cd.length; pp++) {
                text += "" + wl[pp] + "\t" + cd[pp] + "\n"
            }
        }
        text += "@!BUFFEROBJ:" + JSON.stringify(buffer[batch.name]) + "\n"
        download(name + ".dcf", text)
    }
}

function downloadDCS(batches) {
    let name = prompt("Please enter a name for the session file download:", "batches");
    if (name != null) {
        text = ""
        count = 0
        refSetInd = []
        ll = 0
        Object.keys(batches).forEach(function (key, index) {
            if (refSet.includes(batches[key].name)) {
                refSetInd.push(String(index))
            }
        })
        text += "@!NAME:" + String(runname) + "\n"
        text += "@!SCBOOL:" + String(scale_bool) + "\n"
        text += "@!MIN:" + String(wl_range[0]) + "\n"
        text += "@!MAX:" + String(wl_range[1]) + "\n"
        text += "@!ALPHA:" + String(alpha) + "\n"
        text += "@!DEV:" + String(dev_t) + "\n"
        text += "@!INACTIVE:" + JSON.stringify(inactive) + "\n"
        text += "@!ZERO1:" + String(zero_wl1) + "\n"
        text += "@!ZERO2:" + String(zero_wl2) + "\n"
        text += "@!ZEROBOOL:" + String(zero_bool) + "\n"
        text += "@!BUFFEROBJ:" + JSON.stringify(buffer) + "\n"
        text += "@!REFSET:" + JSON.stringify(refSet) + "\n"
        text += "@!REFSETIND:" + JSON.stringify(refSetInd) + "\n"
        text += "@!REFSETINDALL:" + JSON.stringify(refSetIndAll) + "\n"
        text += "@!REFSETACT:" + JSON.stringify(refSetActive) + "\n"
        text += "@!QCBOOL:" + JSON.stringify(qcmode) + "\n"

        Object.keys(batches).forEach(function (key, index) {
            count += 1
            batch = batches[key]

            files = Object.keys(batchesOrig[key].files)
            for (p = 0; p < files.length; p++) {
                text += ">" + files[p] + "\n"
                cd = batchesOrig[key].files[files[p]].cd
                wl = batchesOrig[key].files[files[p]].wl
                for (pp = 0; pp < cd.length; pp++) {
                    text += "" + wl[pp] + "\t" + cd[pp] + "\n"
                }
            }
            if (count != Object.keys(batches).length) {

                text += "@>ACTIVE:" + JSON.stringify(batch.fileList) + "\n"
                text += "#Batch END "+batches[key].userName+"\n"
            } else {

                text += "@>ACTIVE:" + JSON.stringify(batch.fileList) + "\n"
                text += "#Batch END "+batches[key].userName+"\n"
                text += "!SESSION END"
            }
        })
        download(name + ".dcs", text)
        return(true)
    }else{
        return(false)
    }
}

var raw_mb = [[
    'pan2d',
    'zoomIn2d',
    'zoomOut2d',
    {
        name: 'myResetScale2d',
        title: 'Reset axes',
        icon: Plotly.Icons.autoscale,
        click: function (gd) {
            Plotly.relayout(gd, { 'xaxis.autorange': true, 'yaxis.autorange': true, 'yaxis2.range': [2.5, 6] })
        }
    },
    {
        name: 'DownloadPNGCus',
        title: "Download as png",
        icon: Plotly.Icons.camera,
        click: function (gd) {
            let dname = prompt("Please enter a name for the image:", "");

            oldData = JSON.parse(JSON.stringify((gd).data))
            oldDataFull = (gd)._fullData
            oldLayout = JSON.parse(JSON.stringify((gd).layout))
            newData = JSON.parse(JSON.stringify(oldData))
            for (let i = 0; i < oldData.length; i++) {


                if (oldDataFull[i].line != undefined) {
                    newData[i].line = JSON.parse(JSON.stringify(oldDataFull[i].line))
                    newData[i].line.width = 10
                }


            }
            Plotly.downloadImage({ data: newData, layout: oldLayout }, { format: "png", filename: dname, scale: 10 })

            for (let i = 0; i < oldData.length; i++) {


                if (newData[i].line != undefined) {

                    newData[i].line.width = 2
                }


            }




        },

    },
], [

]
]

var gen_mb = [[


    {
        name: 'DownloadPNGCus',
        title: "Download as png",
        icon: Plotly.Icons.camera,
        click: function (gd) {
            let dname = prompt("Please enter a name for the image:", "");

            oldData = JSON.parse(JSON.stringify((gd).data))
            oldDataFull = (gd)._fullData
            oldLayout = JSON.parse(JSON.stringify((gd).layout))
            newData = JSON.parse(JSON.stringify(oldData))
            for (let i = 0; i < oldData.length; i++) {


                if (oldDataFull[i].line != undefined) {
                    newData[i].line = JSON.parse(JSON.stringify(oldDataFull[i].line))
                    newData[i].line.width = 10
                }


            }
            Plotly.downloadImage({ data: newData, layout: oldLayout }, { format: "png", filename: dname, scale: 10 })

            for (let i = 0; i < oldData.length; i++) {


                if (newData[i].line != undefined) {

                    newData[i].line.width = 2
                }


            }


        },

    },
]]

var cd_mb = [[
    'zoom2d',
    'pan2d',
    'zoomIn2d',
    'zoomOut2d',
    'resetScale2d',
    {
        name: 'DownloadPNGCus',
        title: "Download as png",
        icon: Plotly.Icons.camera,
        click: function (gd) {
            let dname = prompt("Please enter a name for the image:", "");

            oldData = JSON.parse(JSON.stringify((gd).data))
            oldDataFull = (gd)._fullData
            oldLayout = JSON.parse(JSON.stringify((gd).layout))
            newData = JSON.parse(JSON.stringify(oldData))
            for (let i = 0; i < oldData.length; i++) {


                if (oldDataFull[i].line != undefined) {
                    newData[i].line = JSON.parse(JSON.stringify(oldDataFull[i].line))
                    newData[i].line.width = 10
                }


            }
            Plotly.downloadImage({ data: newData, layout: oldLayout }, { format: "png", filename: dname, scale: 10 })

            for (let i = 0; i < oldData.length; i++) {


                if (newData[i].line != undefined) {

                    newData[i].line.width = 2
                }


            }


        },

    },
]]




const colScheme = ["#ffaa00", "#00bf66", "#99b4cc", "#e63df2", "#f2553d", "#00cad9", "#3939e6", "#731d56", "#330e00", "#194000", "#005359", "#0e0033", "#ff0088", "#bf9360", "#8fbfa3", "#0091d9"]

const colorBall = chroma.scale(["rgb(19, 214, 45)", "rgb(240, 247, 43)", "rgb(247, 233, 44)", 'rgb(247, 103, 37)', 'rgb(247, 43, 43)']).mode('lab').domain([0, 0.25, 0.4, 0.5, 1.0]).colors(101)
const colorBall2 = ["#ff0416", "#ff0916", "#ff0d16", "#ff1116", "#ff1616", "#ff1a16", "#ff1e16", "#ff2316", "#ff2716", "#ff2c16", "#ff3016", "#ff3416", "#ff3916", "#ff3d16", "#ff4116", "#ff4616", "#ff4a16", "#ff4e16", "#ff5316", "#ff5716", "#ff5b16", "#ff6016", "#ff6416", "#ff6816", "#ff6d16", "#ff7116", "#ff7616", "#ff7a16", "#ff7e16", "#ff8316", "#ff8716", "#ff8b16", "#ff9016", "#ff9416", "#ff9816", "#ff9d16", "#ffa116", "#ffa516", "#ffaa16", "#ffae16", "#ffb216", "#ffb716", "#ffbb16", "#ffc016", "#ffc416", "#ffc816", "#ffcd16", "#ffd116", "#ffd516", "#ffda16", "#fcff16", "#f8fe16", "#f5fe15", "#f1fd15", "#eefd15", "#ebfd15", "#e7fc15", "#e4fc15", "#e0fb14", "#ddfb14", "#dafb14", "#d6fa14", "#d3fa14", "#d0fa14", "#ccf913", "#c9f913", "#c5f813", "#c2f813", "#bff813", "#bbf713", "#b8f712", "#b4f612", "#b1f612", "#aef612", "#aaf512", "#a7f511", "#a3f411", "#a0f411", "#9df411", "#99f311", "#96f311", "#92f210", "#8ff210", "#8cf210", "#88f110", "#85f110", "#82f110", "#7ef00f", "#7bf00f", "#77ef0f", "#74ef0f", "#71ef0f", "#6dee0f", "#6aee0e", "#66ed0e", "#66ed0e", "#66ed0e", "#66ed0e", "#66ed0e", "#66ed0e"]
var dev_t = 0.5

function noiseModel(n) {
    y = math.add(math.dotMultiply(2.8522, n), 2.6655)

    return (y)
}


function minDist(keymax, key) {
    let sgOptions = {
        windowSize: 7,
        derivative: 0,
        polynomial: 2,
    };

    let wl = batches[key].wl
    let mean1 = batches[keymax].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
    //mean1 = SavitzkyGolay(mean1, cur_wlskip, sgOptions)
    let mean2 = batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
    //mean2 = SavitzkyGolay(mean2, cur_wlskip, sgOptions)
    let s_factor = 1.0;
    let dist_old = 10000;
    let dist = 10;
    flag = true

    let trans;
    wl_ind = -1

    if (zero_bool == "true" || zero_bool == true) {

        for (u = 0; u < wl.length; u++) {
            if (wl[u] == zero_wl1) {

                wl_ind = u
            }
        }
    }

    wldiff = (zero_wl2 - zero_wl1) / cur_wlskip + 1

    maxCD = 0
    maxCDWL = 0
    for (u = 0; u < mean1.length; u++) {
        if (math.abs(mean1[u]) > maxCD) {
            maxCDWL = u
        }
    }
    if ((zero_bool == "true" || zero_bool == true) && wl_ind != -1) {


        if (wl[0] < wl[1]) {
            trans1 = math.mean(math.subtract(0, batches[keymax].false.mean.slice(wl_ind, wl_ind + wldiff)))
            trans2 = math.mean(math.subtract(0, batches[key].false.mean.slice(wl_ind, wl_ind + wldiff)))
        } else {
            trans1 = math.mean(math.subtract(0, batches[keymax].false.mean.slice(wl_ind - wldiff + 1, wl_ind + 1)))
            trans2 = math.mean(math.subtract(0, batches[key].false.mean.slice(wl_ind - wldiff + 1, wl_ind + 1)))
        }

    } else {

        trans1 = 0
        trans2 = 0
    }

    if (scale_bool == "true") {
        mean1 = math.add(mean1, trans1)
        mean2 = math.add(mean2, trans2)



        ratio = math.max(math.abs(mean1)) / math.max(math.abs(mean2))
        /* if(ratio-1>4){
            ratio=1.0
        } */

        currentDist = math.mean(math.abs(math.subtract(mean1, math.multiply(mean2, ratio))))
        currentRatio = parseFloat(ratio)
        testRatio = parseFloat(ratio.toFixed(2)) - (0.01 * 125)
        iter = 0
        while (iter < 250) {
            testRatio = testRatio + 0.01
            testDist = math.mean(math.abs(math.subtract(mean1, math.multiply(mean2, testRatio))))
            if (testDist < currentDist) {
                currentDist = parseFloat(testDist)
                currentRatio = parseFloat(testRatio)
            }
            iter++
        }
    } else {
        currentRatio = 1.0
    }


    return ([currentRatio, trans2])
}

function getScalingAN(batches) {
    scaleTab = document.getElementById("scaleList")
    if (Object.keys(batches).length > 0) {

        max = 0
        let allMean = [];
        let all_norm_means = []
        let all_trans = []
        let scActive = []
        text = "<table style='width:95%'><tbody>"
        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {
                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

                let wl = batches[key].wl.slice()
                let mean_all = batches[key].false.mean.slice().wlskip(batches[key].wl, cur_wlskip)
                let mean1 = batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
                let s_factor = 1.0;
                let sgOptions = {
                    windowSize: 7,
                    derivative: 0,
                    polynomial: 2,
                };

                mean_all = SavitzkyGolay(mean_all, cur_wlskip, sgOptions)
                mean1 = SavitzkyGolay(mean1, cur_wlskip, sgOptions)

                flag = true

                let trans = [];
                wl_ind = -1

                if (zero_bool == "true" || zero_bool == true) {


                    for (let u = 0; u < wl.length; u++) {
                        if (wl[u] >= zero_wl1 && wl[u] <= zero_wl2) {

                            trans.push(mean_all[u])
                        }
                    }
                    trans = math.mean(trans)
                } else {
                    trans = 0
                }

                all_trans.push(trans)

                trans_mean1 = math.add(mean1, trans) //translate for zeroing
                abssum_mean1 = math.sum(math.abs(trans_mean1)) // get sum of abs area for normalisation
                norm_mean1 = math.divide(trans_mean1, abssum_mean1) // normalised to an absolute area of 1

                all_norm_means.push(norm_mean1)
                allMean.push(trans_mean1) // put in all the translated means to allow calculation of a mean for scaling factor
                scActive.push(true)

            } else {
                scActive.push(false)
            }
        });

        scaling_factors = []
        mean_mean = math.mean(allMean, 0)  // get the mean of the translated means
        mean_norm_mean = math.mean(all_norm_means, 0)
        mean_sf = math.mean(math.dotDivide(mean_mean, mean_norm_mean))
        upscaled_normMean = math.multiply(mean_norm_mean, mean_sf)

        if (scale_bool == true || scale_bool == "true") {
            let u = 0;
            for (let uu = 0; u < scActive.length; uu++) {
                if (scActive[uu]) {


                    upScaled_mean = math.multiply(all_norm_means[u], math.sum(math.abs(mean_mean)))
                    sf = math.mean(math.dotDivide(all_norm_means[u], allMean[u]))
                    sf2 = sf
                    scaling_factors.push([sf, 0 - all_trans[u]])
                    u++;
                } else {
                    scaling_factors.push(0)
                }


            }
        } else if (scale_bool == false || scale_bool == "false") {
            let u = 0;
            for (let uu = 0; u < scActive.length; uu++) {
                if (scActive[uu]) {
                    scaling_factors.push([1.0, 0 - all_trans[u]])
                    u++
                } else {
                    scaling_factors.push(0)
                }

            }
        }


        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {
                s_factor = scaling_factors[index]

                all_keys = Object.keys(batches[key]["true"])

                for (z = 0; z < all_keys.length; z++) {
                    if (all_keys[z] != "confInt") {
                        batches[key].true[all_keys[z]] = math.multiply(math.add(batches[key].false[all_keys[z]], s_factor[1]), s_factor[0])
                    }

                }

                confInt = []

                for (k = 0; k < batches[key].true.tcdarr.length; k++) {

                    confInt.push(jStat.tci(0, alpha, batches[key].true.tcdarr[k])[1])

                }


                batches[key]["true"].confInt = confInt

                if (scale_bool == "true") {

                    text += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + s_factor[0].toFixed(3) + "</small></td></tr>"
                }
            }

        })
        scaleTab = document.getElementById("scaleList")
        if (scale_bool == "true") {

            text += "</tbody></table>"
            scaleTab.innerHTML = text
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        } else {
            scaleTab.innerHTML = ""
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        }


        return (scaling_factors)
    } else {
        scaleTab.innerHTML = ""
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        return ([1.0, 0])
    }
}

function getScaling(batches) {
    scaleTab = document.getElementById("scaleList")
    if (Object.keys(batches).length > 0) {

        max = 0
        let maxMean;

        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {
                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
                let b_mean = batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
                sumA = math.sum(math.abs(b_mean))
                if (sumA > max) {
                    max = sumA
                    maxMean = b_mean
                    maxKey = key
                }

                text = "<table style='width:95%'><tbody>"
            }
        });

        scaling_factors = []
        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {
                if (key != maxKey) {
                    wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
                    let b_mean = batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
                    s_factor = minDist(maxKey, key)
                    scaling_factors.push(s_factor)

                } else {
                    /* s_factor=[1.0,0]
                    scaling_factors.push(s_factor) */
                    s_factor = minDist(maxKey, key)
                    scaling_factors.push(s_factor)

                }
                all_keys = Object.keys(batches[key]["true"])

                for (z = 0; z < all_keys.length; z++) {
                    if (all_keys[z] != "confInt") {
                        batches[key].true[all_keys[z]] = math.multiply(math.add(batches[key].false[all_keys[z]], s_factor[1]), s_factor[0])
                    }

                }

                confInt = []

                for (k = 0; k < batches[key].true.tcdarr.length; k++) {

                    confInt.push(jStat.tci(0, alpha, batches[key].true.tcdarr[k])[1])

                }


                batches[key]["true"].confInt = confInt

                if (scale_bool == "true") {

                    text += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + s_factor[0].toFixed(3) + "</small></td></tr>"
                }
            } else {
                scaling_factors.push(0)
            }

        })
        scaleTab = document.getElementById("scaleList")
        if (scale_bool == "true") {

            text += "</tbody></table>"
            scaleTab.innerHTML = text
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        } else {
            scaleTab.innerHTML = ""
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        }


        return (scaling_factors)
    } else {
        scaleTab.innerHTML = ""
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        return ([1.0, 0])
    }
}

function getScalingNewFile(batches, newMean) {

    max = 0
    let maxMean;
    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
        let b_mean = batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
        sumA = math.sum(math.abs(b_mean))
        if (sumA > max) {
            max = sumA
            maxMean = b_mean
            maxKey = key
        }


    });

    wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
    let b_mean = newMean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip)
    s_factor = minDist(maxKey, key)
    scaling_factors.push(s_factor)



    return (s_factor)
}


Array.prototype.sum = Array.prototype.sum || function () {
    return this.reduce(function (sum, a) { return sum + Number(a) }, 0);
}

Array.prototype.wlskip = Array.prototype.wlskip || function (wlarr, step) {

    step = math.abs(step)
    newArr = []
    for (index = 0; index < wlarr.length; index++) {
        if (wlarr[index] % step === 0) {
            newArr.push(this[index])

        }
    }
    return (newArr)

}

Array.prototype.average = Array.prototype.average || function () {
    return this.sum() / (this.length || 1);
}

var removeOptions = [
    "select2d",
    "lasso2d", "resetScale2d",
    "hoverClosestCartesian", "hoverCompareCartesian",
    "zoom3d", "pan3d", "resetCameraDefault3d", "resetCameraLastSave3d", "hoverClosest3d",
    "orbitRotation", "tableRotation",
    "zoomInGeo", "zoomOutGeo", "resetGeo", "hoverClosestGeo",

    "sendDataToCloud",
    "hoverClosestGl2d",
    "hoverClosestPie",
    "toggleHover",
    "resetViews",
    "toggleSpikelines",
    "resetViewMapbox"
]


const transpose = m => m[0].map((x, i) => m.map(x => x[i]))

const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");

var alpha = 0.01

var batchCount = 1

var batches = {}
var contents;
var cd_arr;
var wl_arr;

var sFactors;

var scale_bool = "false"

function changeFile(el) {

    let fchecked = document.getElementById(el).checked



    let id = el.split("-")[1]
    if (fchecked) {




        ticks[bkey][parseInt(id) - 1] = true





        cd_arr = []
        f_arr = []

        for (i = 0; i < batchesOrig[bkey].fileList.length; i++) {

            if (i + 1 == parseInt(id)) {

                cd_arr.push(batchesOrig[bkey].false.cdarr[i])
                f_arr.push(batchesOrig[bkey].fileList[i])

            }
            if (batchesOrig[bkey].fileList[i] in batches[bkey].files) {
                cd_arr.push(batchesOrig[bkey].false.cdarr[i])
                f_arr.push(batchesOrig[bkey].fileList[i])
            }

        }



        for (i = 0; i < batchesOrig[bkey].fileList.length; i++) {
            document.getElementById("chk-" + (1 + i)).disabled = false

        }

        batches[bkey].files[batchesOrig[bkey].fileList[parseInt(id) - 1]] = jQuery.extend(true, {}, batchesOrig[bkey].files[batchesOrig[bkey].fileList[parseInt(id) - 1]])

        mean = math.mean(cd_arr, 0)
        batches[bkey]["false"].mean = mean
        mean_z = math.subtract(mean.reverse(), mean.reverse()[0])
        mean_sc = math.divide(mean_z, math.max((mean_z)))
        batches[bkey]["true"].mean = mean_sc

        batches[bkey]["fileList"] = f_arr

        std = []
        stderr = []
        confInt = []
        mad = []
        median = []

        std_sc = []
        stderr_sc = []
        confInt_sc = []


        let cd_arr_t_sc = transpose((math.divide(cd_arr, math.max(math.abs(mean)))))
        batches[bkey]["true"]["tcdarr"] = cd_arr_t_sc

        let cd_arr_t = transpose(cd_arr)
        batches[bkey]["false"]["tcdarr"] = cd_arr_t

        for (k = 0; k < cd_arr_t.length; k++) {
            mad.push(math.std(cd_arr_t[k]))
            median.push(math.median(cd_arr_t[k]))
            s = math.std(cd_arr_t[k])
            std.push(s)
            confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

            stderr.push((s / (math.sqrt(cd_arr_t[k].length))))

            s = math.std(cd_arr_t_sc[k])
            std_sc.push(s)
            confInt_sc.push(jStat.tci(0, alpha, cd_arr_t_sc[k])[1])

            stderr_sc.push((s / (math.sqrt(cd_arr_t_sc[k].length))))

        }



        batches[bkey]["false"].std = std
        batches[bkey]["false"].stderr = stderr
        batches[bkey]["false"].snr = math.dotDivide(math.abs(mean), std)
        batches[bkey]["true"].std = std_sc
        batches[bkey]["true"].stderr = stderr_sc
        batches[bkey]["true"].snr = math.dotDivide(math.abs(mean_sc), std_sc)

        batches[bkey]["false"].confInt = confInt //math.divide(confInt, math.max(math.abs(mean)))
        batches[bkey]["false"].cdarr = transpose(batches[bkey]["false"].tcdarr)
        batches[bkey]["true"].confInt = confInt_sc //math.divide(confInt, math.max(math.abs(mean)))
        batches[bkey]["true"].cdarr = transpose(batches[bkey]["true"].tcdarr)





        bkey_old = bkey



        let raw = batches[bkey].files

        data_preview = []

        for (i = 0; i < batchesOrig[bkey].fileList.length; i++) {
            if (f_arr.includes(batchesOrig[bkey].fileList[i])) {
                data_preview.push({
                    x: raw[batchesOrig[bkey].fileList[i]].wl,
                    y: raw[batchesOrig[bkey].fileList[i]].cd,

                    mode: "lines",
                    name: batchesOrig[bkey].fileList[i],
                    type: "scatter",
                    hoverinfo: "name+x+y",
                    line: {
                        color: colScheme.slice(1)[i]
                    }
                });
            }

        }



        smSD = sGolayG(batches[bkey]["false"].std, math.abs(raw[f_arr[0]].wl[0] - raw[f_arr[0]].wl[1]), { derivative: 0, windowSize: 19, polynomial: 2 })

        noise = noiseModel(smSD)

        batches[bkey].noise = noise

        data_preview.push({

            x: raw[f_arr[0]].wl,
            y: noise,
            fill: 'tozeroy',
            mode: "lines",
            name: "Noise",
            type: "scatter",
            hoverinfo: "name+x+y",
            line: {
                color: "rgb(255, 20, 20)",
                width: 1
            },
            yaxis: 'y2',

        });

        data_preview.push({

            x: raw[f_arr[0]].wl,
            y: Array(noise.length).fill(5),

            mode: "lines",
            name: "Threshold",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(20, 20, 255)",
                width: 2
            },
            yaxis: 'y2',

        });
        data_preview.push({

            x: raw[f_arr[0]].wl,
            y: Array(noise.length).fill(8),

            mode: "lines",
            name: "Threshold",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(255,255,255)",
                width: 2,

            },
            opacity: 0,
            yaxis: 'y2',

        });



        wl_slice = [batches[bkey].wl.indexOf(parseFloat(wl_range[1])), batches[bkey].wl.indexOf(parseFloat(wl_range[0])) + 1]


        wl_shapes = [
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: math.min(raw[f_arr[0]].wl),
                y0: 0,
                x1: wl_range[0],
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            },
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: wl_range[1],
                y0: 0,
                x1: math.max(raw[f_arr[0]].wl),
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            }
        ];

        layoutPre.shapes = wl_shapes


        Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })




        sFactors = getScaling(batches)







        sumPNPC = []

        Object.keys(batches).forEach(function (key, index) {

            wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]





            stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
            diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
            positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);



            batches[key].noisePC = positiveNumbersPC;




            batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
            if (inactive.includes(key) == false) {
                sumPNPC.push(positiveNumbersPC)
                data[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                };
                data2[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    error_y: {
                        type: 'data',
                        array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        visible: true
                    },
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",

                };
            }
        });

        if (sumPNPC.length > 0) {
            noiseWeighting = 1 - (math.mean(sumPNPC))
        } else {
            noiseWeighting = 1
        }


        data_l = [];
        data_l2 = [];




        document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
        document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
        document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
        document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])

        Object.keys(data).forEach(function (key, index) {



            data_l.push(data[key])
            data_l2.push(data2[key])

        });
        index_ofWL = batches[bkey].wl.indexOf(math.mean(wl_range))
        data_hm = CIOverlap(batches)
        yrange_tmp = [batches[bkey]["true"].mean[index_ofWL] - batches[bkey]["true"].confInt[index_ofWL] * 4, batches[bkey]["true"].mean[index_ofWL] + batches[bkey]["true"].confInt[index_ofWL] * 4]
        xrange_tmp = [parseInt(math.mean(wl_range)) - 4, parseInt(math.mean(wl_range)) + 4]

        Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })


        additional = (maxWL - minWL) * 0.05
        layoutOL.xaxis.range = myPlot2.layout.xaxis.range

    } else {

        if (batches[bkey].fileList.length === 2) {


        }

        ticks[bkey][parseInt(id) - 1] = false

        cd_arr = []
        f_arr = []

        for (i = 0; i < batches[bkey].fileList.length; i++) {
            if (batches[bkey].fileList[i] != batchesOrig[bkey].fileList[parseInt(id) - 1]) {
                cd_arr.push(batches[bkey].false.cdarr[i])
                f_arr.push(batches[bkey].fileList[i])

            }
        }
        delete batches[bkey].files[batchesOrig[bkey].fileList[parseInt(id) - 1]]



        if (f_arr.length === 2) {
            document.getElementById("chk-" + (1 + batchesOrig[bkey].fileList.indexOf(f_arr[0]))).disabled = true
            document.getElementById("chk-" + (1 + batchesOrig[bkey].fileList.indexOf(f_arr[1]))).disabled = true
        }

        mean = math.mean(cd_arr, 0)
        batches[bkey]["false"].mean = mean
        mean_z = math.subtract(mean.reverse(), mean.reverse()[0])
        mean_sc = math.divide(mean_z, math.max((mean_z)))
        batches[bkey]["true"].mean = mean_sc

        batches[bkey]["fileList"] = f_arr

        std = []
        stderr = []
        confInt = []
        mad = []
        median = []

        std_sc = []
        stderr_sc = []
        confInt_sc = []


        let cd_arr_t_sc = transpose((math.divide(cd_arr, math.max(math.abs(mean)))))
        batches[bkey]["true"]["tcdarr"] = cd_arr_t_sc

        let cd_arr_t = transpose(cd_arr)
        batches[bkey]["false"]["tcdarr"] = cd_arr_t

        for (k = 0; k < cd_arr_t.length; k++) {
            mad.push(math.std(cd_arr_t[k]))
            median.push(math.median(cd_arr_t[k]))
            s = math.std(cd_arr_t[k])
            std.push(s)
            confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

            stderr.push((s / (math.sqrt(cd_arr_t[k].length))))

            s = math.std(cd_arr_t_sc[k])
            std_sc.push(s)
            confInt_sc.push(jStat.tci(0, alpha, cd_arr_t_sc[k])[1])

            stderr_sc.push((s / (math.sqrt(cd_arr_t_sc[k].length))))

        }



        batches[bkey]["false"].std = std
        batches[bkey]["false"].stderr = stderr
        batches[bkey]["false"].snr = math.dotDivide(math.abs(mean), std)
        batches[bkey]["true"].std = std_sc
        batches[bkey]["true"].stderr = stderr_sc
        batches[bkey]["true"].snr = math.dotDivide(math.abs(mean_sc), std_sc)

        batches[bkey]["false"].confInt = confInt //math.divide(confInt, math.max(math.abs(mean)))
        batches[bkey]["false"].cdarr = transpose(batches[bkey]["false"].tcdarr)
        batches[bkey]["true"].confInt = confInt_sc //math.divide(confInt, math.max(math.abs(mean)))
        batches[bkey]["true"].cdarr = transpose(batches[bkey]["true"].tcdarr)

        bkey_old = bkey

        let raw = batches[bkey].files

        data_preview = []

        for (i = 0; i < batchesOrig[bkey].fileList.length; i++) {
            if (f_arr.includes(batchesOrig[bkey].fileList[i])) {
                data_preview.push({
                    x: raw[batchesOrig[bkey].fileList[i]].wl,
                    y: raw[batchesOrig[bkey].fileList[i]].cd,

                    mode: "lines",
                    name: batchesOrig[bkey].fileList[i],
                    type: "scatter",
                    hoverinfo: "name+x+y",
                    line: {
                        color: colScheme.slice(1)[i]
                    }
                });
            }

        }

        smSD = sGolayG(batches[bkey]["false"].std, math.abs(raw[f_arr[0]].wl[0] - raw[f_arr[0]].wl[1]), { derivative: 0, windowSize: 19, polynomial: 2 })

        noise = noiseModel(smSD)

        batches[bkey].noise = noise

        data_preview.push({
            x: raw[f_arr[0]].wl,
            y: noise,
            fill: 'tozeroy',
            mode: "lines",
            name: "Noise",
            type: "scatter",
            hoverinfo: "name+x+y",
            line: {
                color: "rgb(255, 20, 20)",
                width: 1
            },
            yaxis: 'y2',

        });

        data_preview.push({

            x: raw[f_arr[0]].wl,
            y: Array(noise.length).fill(5),

            mode: "lines",
            name: "Noise Cutoff",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(20, 20, 255)",
                width: 2
            },
            yaxis: 'y2',

        });
        data_preview.push({
            x: raw[f_arr[0]].wl,
            y: Array(noise.length).fill(8),

            mode: "lines",
            name: "Threshold",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(255,255,255)",
                width: 2,

            },
            opacity: 0,
            yaxis: 'y2',

        });

        wl_slice = [batches[bkey].wl.indexOf(parseFloat(wl_range[1])), batches[bkey].wl.indexOf(parseFloat(wl_range[0])) + 1]

        wl_shapes = [
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: math.min(raw[f_arr[0]].wl),
                y0: 0,
                x1: wl_range[0],
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            },
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: wl_range[1],
                y0: 0,
                x1: math.max(raw[f_arr[0]].wl),
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            }
        ];

        layoutPre.shapes = wl_shapes


        Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })




        sFactors = getScaling(batches)





        wl_slice = [batches[bkey].wl.indexOf(parseFloat(wl_range[1])), batches[bkey].wl.indexOf(parseFloat(wl_range[0])) + 1]

        sumPNPC = []

        Object.keys(batches).forEach(function (key, index) {

            wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]





            stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
            diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
            positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);

            batches[key].noisePC = positiveNumbersPC;

            batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
            if (inactive.includes(key) == false) {
                sumPNPC.push(positiveNumbersPC)
                data[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                };
                data2[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    error_y: {
                        type: 'data',
                        array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        visible: true
                    },
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",

                };
            }
        });

        if (sumPNPC.length > 0) {
            noiseWeighting = 1 - (math.mean(sumPNPC))
        } else {
            noiseWeighting = 1
        }

        data_l = [];
        data_l2 = [];




        document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
        document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
        document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
        document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
        Object.keys(data).forEach(function (key, index) {



            data_l.push(data[key])
            data_l2.push(data2[key])

        });
        index_ofWL = batches[bkey].wl.indexOf(math.mean(wl_range))
        data_hm = CIOverlap(batches)
        yrange_tmp = [batches[bkey]["true"].mean[index_ofWL] - batches[bkey]["true"].confInt[index_ofWL] * 4, batches[bkey]["true"].mean[index_ofWL] + batches[bkey]["true"].confInt[index_ofWL] * 4]
        xrange_tmp = [parseInt(math.mean(wl_range)) - 4, parseInt(math.mean(wl_range)) + 4]

        Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

        additional = (maxWL - minWL) * 0.05
        layoutOL.xaxis.range = myPlot2.layout.xaxis.range


    }
}


var downloadButtonOpt = {
    format: 'png', // one of png, svg, jpeg, webp
    filename: 'custom_image',

    scale: 10 // Multiply title/legend/axis/canvas sizes by this factor
}



function removeBatch(e) {
    let i = e.target.id;

    delete batches[String(i)]
    delete batchesOrig[String(i)]
    delete buffer[String(i)]

    document.getElementById(i + "-div").remove()

    delete data[String(i)]
    tmpRefSet = []
    for (let j = 0; j < refSet.length; j++) {
        if (refSet[j] != i) {
            tmpRefSet.push(refSet[j])
        }
    }
    refSet = tmpRefSet;

    minWL = -1;
    maxWL = 999999;
    bkey = 0;
    batches_l = []
    Object.keys(batches).forEach(function (key, index) {
        document.getElementById("" + key + "-div").setAttribute("style", "background-color: transparent")

        document.getElementById("ball-" + key).setAttribute('style', 'height:15px;width:15px;background-color:' + colScheme[(index + 1) % colScheme.length])

        if (math.min(batches[key].wl) > minWL) {
            minWL = math.min(batches[key].wl)
        }
        if (math.max(batches[key].wl) < maxWL) {
            maxWL = math.max(batches[key].wl)
        }
        batches_l.push(batches[key])

    })

    if (zero_wl1 > maxWL || zero_wl1 < minWL) {
        zero_numb1.value = maxWL
        zero_numb1.max = maxWL
        zero_numb1.min = minWL
        zero_wl1 = maxWL
    }
    if (zero_wl2 > maxWL || zero_wl2 < minWL) {
        zero_numb2.value = maxWL
        zero_numb2.max = maxWL
        zero_numb2.min = minWL
        zero_wl2 = maxWL

    }

    sFactors = getScaling(batches)

    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

        slider_wl.noUiSlider.updateOptions({
            range: {
                'min': minWL,
                'max': maxWL,
            }
        })

        slider_wl.noUiSlider.set([wl_range[0], wl_range[1]])
        if (inactive.includes(key) == false) {
            data[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),

                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });

    data_l = [];
    data_l2 = [];

    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });

    batches_l = []

    Object.keys(batches).forEach(function (key, index) {
        if (!inactive.includes(key)) {
            batches_l.push(batches[key])
        }
    });


    data_hm = CIOverlap(batches)


    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

    document.getElementById("plotly-divRaw").setAttribute('style', "display:none")
    document.getElementById("plotly-divHmTrend").setAttribute('style', "display:none")
    document.getElementById("batchFileList").setAttribute('style', "overflow-y:scroll; height:280px; width:100%; display:none")
    document.getElementById("batchFileListTitle").setAttribute('style', "display:none")
    document.getElementById("summary").setAttribute('style', "display:none;border-left: 1px solid #c8caca;")


    if (data_l.length == 1) {
        wl_range = [-1, 999999]
        minWL = -1;
        maxWL = 999999;
        slider_wl.noUiSlider.updateOptions({
            range: {
                'min': minWL,
                'max': maxWL
            },
            tooltips: true,

        })
        slider_wl.noUiSlider.set([minWL, maxWL])
        slider_wl.setAttribute('disabled', true)
        zero_numb1.value = 1000
        zero_wl1 = 1000
        zero_numb2.value = 1000
        zero_wl2 = 1000
    }

}

/* From  https://www.math.ucla.edu/~tom/distributions/tDist.html */
function LogGamma(Z) {
    with (Math) {
        var S = 1 + 76.18009173 / Z - 86.50532033 / (Z + 1) + 24.01409822 / (Z + 2) - 1.231739516 / (Z + 3) + .00120858003 / (Z + 4) - .00000536382 / (Z + 5);
        var LG = (Z - .5) * log(Z + 4.5) - (Z + 4.5) + log(S * 2.50662827465);
    }
    return LG
}

function Betinc(X, A, B) {
    var A0 = 0;
    var B0 = 1;
    var A1 = 1;
    var B1 = 1;
    var M9 = 0;
    var A2 = 0;
    var C9;
    while (Math.abs((A1 - A2) / A1) > .00001) {
        A2 = A1;
        C9 = -(A + M9) * (A + B + M9) * X / (A + 2 * M9) / (A + 2 * M9 + 1);
        A0 = A1 + C9 * A0;
        B0 = B1 + C9 * B0;
        M9 = M9 + 1;
        C9 = M9 * (B - M9) * X / (A + 2 * M9 - 1) / (A + 2 * M9);
        A1 = A0 + C9 * A1;
        B1 = B0 + C9 * B1;
        A0 = A0 / B1;
        B0 = B0 / B1;
        A1 = A1 / B1;
        B1 = 1;
    }
    return A1 / A
}

function compute(X, df) {

    with (Math) {
        if (df <= 0) {
            alert("Degrees of freedom must be positive")
        } else {
            A = df / 2;
            S = A + .5;
            Z = df / (df + X * X);
            BT = exp(LogGamma(S) - LogGamma(.5) - LogGamma(A) + A * log(Z) + .5 * log(1 - Z));
            if (Z < (A + 1) / (S + 2)) {
                betacdf = BT * Betinc(Z, A, .5)
            } else {
                betacdf = 1 - BT * Betinc(1 - Z, .5, A)
            }
            if (X < 0) {
                tcdf = betacdf / 2
            } else {
                tcdf = 1 - betacdf / 2
            }
        }
        tcdf = tcdf;
    }
    return (tcdf)
}



function clearFileInput(ctrl) {
    try {
        ctrl.value = null;
    } catch (ex) { }
    if (ctrl.value) {
        ctrl.parentNode.replaceChild(ctrl.cloneNode(true), ctrl);
    }
}





function mre2de(key) {



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = math.dotDivide(batches[key][boolch[i]]["confInt"], 3298)
        batches[key][boolch[i]]["mean"] = math.dotDivide(batches[key][boolch[i]]["mean"], 3298)
        batches[key][boolch[i]]["std"] = math.dotDivide(batches[key][boolch[i]]["std"], 3298)
        batches[key][boolch[i]]["stderr"] = math.dotDivide(batches[key][boolch[i]]["stderr"], 3298)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = math.dotDivide(batches[key][boolch[i]]["cdarr"][j], 3298)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = math.dotDivide(batches[key][boolch[i]]["tcdarr"][j], 3298)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = math.dotDivide(batches[key]["files"][key2].cd, 3298)
    })

}

function de2mre(key) {



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = math.dotMultiply(batches[key][boolch[i]]["confInt"], 3298)
        batches[key][boolch[i]]["mean"] = math.dotMultiply(batches[key][boolch[i]]["mean"], 3298)
        batches[key][boolch[i]]["std"] = math.dotMultiply(batches[key][boolch[i]]["std"], 3298)
        batches[key][boolch[i]]["stderr"] = math.dotMultiply(batches[key][boolch[i]]["stderr"], 3298)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = math.dotMultiply(batches[key][boolch[i]]["cdarr"][j], 3298)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = math.dotMultiply(batches[key][boolch[i]]["tcdarr"][j], 3298)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = math.dotMultiply(batches[key]["files"][key2].cd, 3298)
    })


}

function machine2de(key, mrw, pl, conc) {
    function machine2deFunc(arr, mrw, pl, conc) {
        coeff = (0.1 * mrw) / (pl * conc)
        de = math.dotMultiply(arr, coeff * 3298)
        return (de)
    }



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = machine2deFunc(batches[key][boolch[i]]["confInt"], mrw, pl, conc)
        batches[key][boolch[i]]["mean"] = machine2deFunc(batches[key][boolch[i]]["mean"], mrw, pl, conc)
        batches[key][boolch[i]]["std"] = machine2deFunc(batches[key][boolch[i]]["std"], mrw, pl, conc)
        batches[key][boolch[i]]["stderr"] = machine2deFunc(batches[key][boolch[i]]["stderr"], mrw, pl, conc)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = machine2deFunc(batches[key][boolch[i]]["cdarr"][j], mrw, pl, conc)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = machine2deFunc(batches[key][boolch[i]]["tcdarr"][j], mrw, pl, conc)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = machine2deFunc(batches[key]["files"][key2].cd, mrw, pl, conc)
    })


}

function machine2mre(key, mrw, pl, conc) {
    function machine2deFunc(arr, mrw, pl, conc) {
        coeff = (0.1 * mrw) / (pl * conc)
        de = math.dotMultiply(arr, coeff)
        return (de)
    }



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = machine2deFunc(batches[key][boolch[i]]["confInt"], mrw, pl, conc)
        batches[key][boolch[i]]["mean"] = machine2deFunc(batches[key][boolch[i]]["mean"], mrw, pl, conc)
        batches[key][boolch[i]]["std"] = machine2deFunc(batches[key][boolch[i]]["std"], mrw, pl, conc)
        batches[key][boolch[i]]["stderr"] = machine2deFunc(batches[key][boolch[i]]["stderr"], mrw, pl, conc)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = machine2deFunc(batches[key][boolch[i]]["cdarr"][j], mrw, pl, conc)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = machine2deFunc(batches[key][boolch[i]]["tcdarr"][j], mrw, pl, conc)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = machine2deFunc(batches[key]["files"][key2].cd, mrw, pl, conc)
    })


}

function de2machine(key, mrw, pl, conc) {
    function machine2deFunc(arr, mrw, pl, conc) {
        coeff = (0.1 * mrw) / (pl * conc)
        de = math.dotDivide(arr, coeff * 3298)
        return (de)
    }



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = machine2deFunc(batches[key][boolch[i]]["confInt"], mrw, pl, conc)
        batches[key][boolch[i]]["mean"] = machine2deFunc(batches[key][boolch[i]]["mean"], mrw, pl, conc)
        batches[key][boolch[i]]["std"] = machine2deFunc(batches[key][boolch[i]]["std"], mrw, pl, conc)
        batches[key][boolch[i]]["stderr"] = machine2deFunc(batches[key][boolch[i]]["stderr"], mrw, pl, conc)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = machine2deFunc(batches[key][boolch[i]]["cdarr"][j], mrw, pl, conc)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = machine2deFunc(batches[key][boolch[i]]["tcdarr"][j], mrw, pl, conc)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = machine2deFunc(batches[key]["files"][key2].cd, mrw, pl, conc)
    })


}

function mre2machine(key, mrw, pl, conc) {
    function machine2deFunc(arr, mrw, pl, conc) {
        coeff = (0.1 * mrw) / (pl * conc)
        de = math.dotDivide(arr, coeff)
        return (de)
    }



    let boolch = ["true", "false"]
    for (i = 0; i < 2; i++) {
        batches[key][boolch[i]]["confInt"] = machine2deFunc(batches[key][boolch[i]]["confInt"], mrw, pl, conc)
        batches[key][boolch[i]]["mean"] = machine2deFunc(batches[key][boolch[i]]["mean"], mrw, pl, conc)
        batches[key][boolch[i]]["std"] = machine2deFunc(batches[key][boolch[i]]["std"], mrw, pl, conc)
        batches[key][boolch[i]]["stderr"] = machine2deFunc(batches[key][boolch[i]]["stderr"], mrw, pl, conc)
        for (j = 0; j < batches[key][boolch[i]]["cdarr"].length; j++) {
            batches[key][boolch[i]]["cdarr"][j] = machine2deFunc(batches[key][boolch[i]]["cdarr"][j], mrw, pl, conc)
        }
        for (j = 0; j < batches[key][boolch[i]]["tcdarr"].length; j++) {
            batches[key][boolch[i]]["tcdarr"][j] = machine2deFunc(batches[key][boolch[i]]["tcdarr"][j], mrw, pl, conc)
        }
    }
    Object.keys(batches[key]["files"]).forEach(function (key2, index2) {
        batches[key]["files"][key2].cd = machine2deFunc(batches[key]["files"][key2].cd, mrw, pl, conc)
    })


}

function chavenetCriterion(u, std, n, x) {

    outlier = false
    Pz = 1 - (1 / (4 * n))
    Z2 = qnorm(Pz)
    d = math.abs(x - u)
    Z = d / std
    Pz2 = jStat.ztest(Z, 1)
    if (Z > Z2) {
        outlier = true
    }
    cutoff_d = Z2 * std


    return ([outlier, d, Pz, Pz2, cutoff_d])
}

function drawBufferPlot(batNo) {



    if (buffer[batNo].files != undefined) {


        data_buffer = []
        data_buff_names = "<table><tbody>"
        Object.keys(buffer[batNo].files).forEach(function (key, index) {




            data_buffer.push({


                x: buffer[batNo].files[key].wl,

                y: buffer[batNo].files[key].cd,

                mode: "line",
                name: key,
                type: "scatter",

                hoverinfo: "name+x+y",
                line: {
                    color: colScheme.slice(1)[index],

                }
            });
            data_buff_names += "<tr><td><span class='dot' style='background-color:" + colScheme.slice(1)[index] + "; height:10px;width:10px;'></span></td><td><small>" + key + "</small></td></tr>"


        });

        data_buff_names += "</tbody></table>"
        document.getElementById("bufferFileList").style.display = "block"
        document.getElementById("bufferFileList").innerHTML = data_buff_names

        Plotly.react('plotly-divBuffer', data_buffer, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    } else {

        document.getElementById("bufferFileList").innerHTML = "<small>None</small>"
        Plotly.purge("plotly-divBuffer")
    }
}

function drawOutliersPlot(b) {


    document.getElementById("outlier-table").innerHTML = b.outliers_table
    data_outliers = []

    kkk = 0
    ticknames = []
    bestYvals = 0
    Object.keys(b["outliers"]).forEach(function (key, index) {
        if (key != "outlierPC" && key != "d_cut") {
            kkk++
            ticknames.push(key)

            if (key.length > 12) {
                name = key.slice(0, 6) + "..." + key.slice(key.length - 7)
            } else {
                name = key.slice()
            }

            label = []
            dmaxDiff = math.subtract(b.outliers[key].d_bad, b.outliers[key].d_cut_bad)
            for (kk = 0; kk < b.outliers[key].wl_bad.length; kk++) {
                label.push(b.outliers[key].wl_bad[kk] + " nm<br>" + dmaxDiff[kk].toFixed(2) + " ")
            }

            if (b.outliers[key].wl_bad.length > 0) {
                yvals = math.add(Array.from(Array(b.outliers[key].wl_bad.length).keys()), 1)
                if (yvals.length > bestYvals) {
                    bestYvals = yvals.length
                }
                data_outliers.push({


                    x: Array(yvals.length).fill(kkk),

                    y: yvals,
                    text: label,
                    mode: "markers",
                    name: key,
                    type: "scatter",

                    hovertemplate: "%{text}",
                    marker: {
                        color: colScheme.slice(1)[index],
                        size: 7,
                        symbol: "circle",
                        line: {
                            color: 'black',
                            width: 1
                        }
                    }
                });
            } else {

            }

        }

    });

    layoutOutliers.xaxis.tickvals = math.add(Array.from(Array(kkk).keys()), 1)
    layoutOutliers.xaxis.ticktext = ticknames
    layoutOutliers.xaxis.range = [0, kkk + 1]
    layoutOutliers.yaxis.range = [0, maxOutlier + 1]

    Plotly.react('plotly-divOutliers', data_outliers, layoutOutliers, { modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
}

var maxOutlier = 0;

function getOutliers(b, f_arr) {

    let flist = f_arr
    let Us = b.false.mean
    let stds = b.false.std
    b["outliers"] = {}
    outliers_c = []
    outliers_table = "<tbody>"
    outlierPCs = []
    for (k = 0; k < flist.length; k++) {
        ds = []
        ds_bad = []
        ds_cut = []
        ds_cut_bad = []
        wl_bad = []
        outliers = []
        b.outliers[flist[k]] = {}
        for (qq = 0; qq < b.files[flist[k]].cd.length; qq++) {
            chav = chavenetCriterion(Us[qq], stds[qq], flist.length, b.files[flist[k]].cd[qq])
            ds.push(chav[1])
            ds_cut.push(chav[4])
            outliers.push(chav[0])
            if (chav[0] == true) {
                ds_bad.push(chav[1])
                ds_cut_bad.push(chav[4])
                wl_bad.push(b.files[flist[k]].wl[qq])
            }
        }
        b.outliers[flist[k]]["bool"] = outliers
        b.outliers[flist[k]]["d"] = ds
        b.outliers[flist[k]]["wl_bad"] = wl_bad
        b.outliers[flist[k]]["d_bad"] = ds_bad
        b.outliers[flist[k]]["d_cut_bad"] = ds_cut_bad

        if (ds_bad.length > maxOutlier) {
            maxOutlier = ds_bad.length
        }


        outlierPC = ds_bad.length / ds.length
        outlierPCs.push(outlierPC)

        if (outlierPC > 0.1) {
            outliers_table += "<tr><td><span class='dot' style='background-color:" + colScheme[(k + 1) % colScheme.length] + "; height:10px;width:10px;'></span></td><td><span style='color:#bf320f'><small>" + ((outlierPC) * 100).toFixed(1) + "%</small></span></td><tr>"
            outliers_c.push("<tr><td><span class='dot' style='background-color:" + colScheme[(k + 1) % colScheme.length] + "; height:10px;width:10px;'></span></td><td><span style='color:#bf320f'><b><small>" + flist[k] + "</small></b></span></td>" + '<td><input onclick="changeFile(this.id)" style="text-align:right" type="checkbox" name="chk-' + (k + 1) + '" id="chk-' + (k + 1) + '" value="" checked></td></tr>')
        } else {
            outliers_table += "<tr><td><span class='dot' style='background-color:" + colScheme[(k + 1) % colScheme.length] + "; height:10px;width:10px;'></span></td><td><span style='color:#000000'><small>" + ((outlierPC) * 100).toFixed(1) + "%</small></span></td><tr>"
            outliers_c.push("<tr><td><span class='dot' style='background-color:" + colScheme[(k + 1) % colScheme.length] + "; height:10px;width:10px;'></span></td><td><span style='color:#000000'><small>" + flist[k] + "</small></span></td>" + '<td><input onclick="changeFile(this.id)" style="text-align:right" type="checkbox" name="chk-' + (k + 1) + '" id="chk-' + (k + 1) + '" value="" checked></td></tr>')
        }
    }
    outliers_table += "</tbody>"
    b.outliers["d_cut"] = ds_cut
    b.outliers["outlierPC"] = outlierPCs
    b.outliers_c = outliers_c
    b.outliers_table = outliers_table

    drawOutliersPlot(b)



}

function sort2Lists(a1, a2) {

    var list = [];
    for (var j = 0; j < a1.length; j++)
        list.push({ 'a1': a1[j], 'a2': a2[j] });


    list.sort(function (a, b) {
        return ((a.a1 < b.a1) ? -1 : ((a.a1 == b.a1) ? 0 : 1));


    });


    for (var k = 0; k < list.length; k++) {
        a1[k] = list[k].a1;
        a2[k] = list[k].a2;
    }
    return ({ "a1": a1, "a2": a2 })
}

var bkey = 0



var data_preview = []

function getBatchInfo(el) {
    document.getElementById("batchFileListTitle").setAttribute('style', 'display:visible')
    document.getElementById("plotly-divRaw").setAttribute('style', "display:visible")
    document.getElementById("plotly-divHmTrend").setAttribute('style', "display:visible")
    document.getElementById("batchFileList").setAttribute('style', "overflow-y:scroll; height:280px; width:100%; display:visible")
    document.getElementById("summary").setAttribute('style', "display:visible;border-left: 1px solid #c8caca;")

    bkey = el.id.split("-")[0]

    document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
    document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
    document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
    document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
    Object.keys(batches).forEach(function (key, index) {


        document.getElementById("" + key + "-div").setAttribute("style", "background-color: transparent")

    });

    document.getElementById("" + bkey + "-div").setAttribute("style", "background-color:#dbdbdb ")
    if (bkey != bkey_old) {



        bkey_old = bkey

        /* let trend_info=batches[String(bkey)].trend */

        let flist = batches[String(bkey)].fileList



        unitSele = ``

        unitSele += `</tr><table>`

        if("conc" in buffer[bkey]){ // check this info exists
            console.log("TODO")
        }

        document.getElementById('batchFileList').innerHTML = "<table style='width:95%'><tbody>" + batches[bkey].outliers_c.join("") + "</tbody</table"
        document.getElementById("batchFileListTitle").innerHTML = "<table><tr><td><h6>B" + String(bkey) + ": "+batches[bkey].userName + " Summary</h6></td>"+ unitSele + "<hr>"

        for (i = 0; i < ticks[bkey].length; i++) {
            if (ticks[bkey][i] == false) {
                document.getElementById("chk-" + (i + 1)).checked = false
            }
        }

        let raw = batches[String(bkey)].files
        data_preview = []

        for (i = 0; i < batchesOrig[bkey].fileList.length; i++) {
            if (flist.includes(batchesOrig[bkey].fileList[i])) {
                data_preview.push({
                    x: raw[batchesOrig[bkey].fileList[i]].wl,
                    y: raw[batchesOrig[bkey].fileList[i]].cd,

                    mode: "lines",
                    name: batchesOrig[bkey].fileList[i],
                    type: "scatter",
                    hoverinfo: "name+x+y",
                    line: {
                        color: colScheme.slice(1)[i]
                    }
                });
            }

        }


        noise = batches[bkey].noise


        data_preview.push({
            x: batches[String(bkey)].wl,
            y: noise,
            fill: 'tozeroy',
            mode: "lines",
            name: "Noise",
            type: "scatter",
            hoverinfo: "name+x+y",
            line: {
                color: "rgb(255, 20, 20)",
                width: 1
            },
            yaxis: 'y2'

        });

        data_preview.push({
            x: batches[String(bkey)].wl,
            y: Array(noise.length).fill(5),

            mode: "lines",
            name: "Noise Cutoff",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(20, 20, 255)",
                width: 2
            },
            yaxis: 'y2'
        });
        data_preview.push({
            x: batches[String(bkey)].wl,
            y: Array(noise.length).fill(8),

            mode: "lines",
            name: "Threshold",
            type: "scatter",
            hoverinfo: "name",
            line: {
                color: "rgb(255,255,255)",
                width: 2,

            },
            opacity: 0,
            yaxis: 'y2',

        });

        wl_shapes = [
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: math.min(batches[String(bkey)].wl),
                y0: 0,
                x1: wl_range[0],
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            },
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: wl_range[1],
                y0: 0,
                x1: math.max(batches[String(bkey)].wl),
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            }
        ];

        layoutPre.shapes = wl_shapes


        Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

        drawOutliersPlot(batches[String(bkey)])
        drawBufferPlot(String(bkey))

    }


}

var dev_threshold = document.getElementById("devThresh")
dev_threshold.value = 0.5
dev_t = 0.5

dev_threshold.addEventListener('change', function (e) {
    dev_t = parseFloat(e.target.value)
    CIOverlap(batches)
})

var scale_chk = document.getElementById("scale")
scale_chk.checked = false

var zero_chk = document.getElementById("zeroData")
zero_chk.checked = false
var zero_bool = false

var zero_numb1 = document.getElementById("zeroWL1")
zero_numb1.value = 1000
var zero_wl1 = 1000

var zero_numb2 = document.getElementById("zeroWL2")
zero_numb2.value = 1000
var zero_wl2 = 1000

scale_chk.addEventListener('change', function (e) {
    scale_bool = String(e.target.checked)
    text0 = "<table style='width:95%'><tbody>"
    sFactors = getScaling(batches)
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {


            if (scale_bool == "true") {

                text0 += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + sFactors[index][0].toFixed(3) + "</small></td></tr>"
            }


            wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
            let cd_arr_t = batches[key]["true"]["tcdarr"]

            confInt = []

            for (k = 0; k < cd_arr_t.length; k++) {

                confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

            }


            batches[key]["true"].confInt = confInt

            data[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),

                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });
    scaleTab = document.getElementById("scaleList")
    if (scale_bool == "true") {

        text0 += "</tbody></table>"

        scaleTab.innerHTML = text0
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
    } else {
        scaleTab.innerHTML = ""
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
    }




    data_l = [];
    data_l2 = [];

    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });



    data_hm = CIOverlap(batches)
    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

    additional = (maxWL - minWL) * 0.05
    layoutOL.xaxis.range = myPlot2.layout.xaxis.range



})

zero_chk.addEventListener('change', function (e) {
    zero_bool = String(e.target.checked)
    text0 = "<table style='width:95%'><tbody>"
    sFactors = getScaling(batches)
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {


            if (scale_bool == "true") {

                text0 += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + sFactors[index][0].toFixed(3) + "</small></td></tr>"
            }

            wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
            let cd_arr_t = batches[key]["true"]["tcdarr"]

            confInt = []

            for (k = 0; k < cd_arr_t.length; k++) {

                confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

            }


            batches[key]["true"].confInt = confInt

            data[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),

                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });
    scaleTab = document.getElementById("scaleList")
    if (scale_bool == "true") {

        text0 += "</tbody></table>"
        scaleTab.innerHTML = text0
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
    } else {
        scaleTab.innerHTML = ""
        scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
    }




    data_l = [];
    data_l2 = [];

    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });



    data_hm = CIOverlap(batches)
    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

    additional = (maxWL - minWL) * 0.05
    layoutOL.xaxis.range = myPlot2.layout.xaxis.range



})

zero_numb1.addEventListener('change', function (e) {
    zero_wl1 = parseInt(zero_numb1.value)
    if (zero_wl1 > zero_wl2) {
        zero_wl1 = zero_wl2 + 0
        zero_numb1.value = zero_wl1
    }

    sFactors = getScaling(batches)
    if (zero_bool) {
        text = "<table style='width:95%'><tbody>"

        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {


                if (scale_bool == "true") {

                    text += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + sFactors[index][0].toFixed(3) + "</small></td></tr>"
                }

                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
                let cd_arr_t = batches[key]["true"]["tcdarr"]

                confInt = []

                for (k = 0; k < cd_arr_t.length; k++) {

                    confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

                }


                batches[key]["true"].confInt = confInt

                data[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                };
                data2[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    error_y: {
                        type: 'data',
                        array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        visible: true
                    },
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",

                };
            }
        });
        scaleTab = document.getElementById("scaleList")
        if (scale_bool == "true") {

            text += "</tbody></table>"
            scaleTab.innerHTML = text
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        } else {
            scaleTab.innerHTML = ""
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        }




        data_l = [];
        data_l2 = [];

        Object.keys(data).forEach(function (key, index) {



            data_l.push(data[key])
            data_l2.push(data2[key])

        });



        data_hm = CIOverlap(batches)
        Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

        additional = (maxWL - minWL) * 0.05
        layoutOL.xaxis.range = myPlot2.layout.xaxis.range


    }
})

zero_numb2.addEventListener('change', function (e) {

    zero_wl2 = parseInt(zero_numb2.value)
    if (zero_wl2 < zero_wl1) {
        zero_wl2 = zero_wl1 + 0
        zero_numb2.value = zero_wl2
    }

    sFactors = getScaling(batches)
    if (zero_bool) {
        text = "<table style='width:95%'><tbody>"

        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {


                if (scale_bool == "true") {

                    text += "<tr><td><small>B" + key + " - "+batches[key].userName + ":</small></td><td><small>" + sFactors[index][0].toFixed(3) + "</small></td></tr>"
                }

                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
                let cd_arr_t = batches[key]["true"]["tcdarr"]

                confInt = []

                for (k = 0; k < cd_arr_t.length; k++) {

                    confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

                }


                batches[key]["true"].confInt = confInt

                data[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                };
                data2[key] = {
                    x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    error_y: {
                        type: 'data',
                        array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        visible: true
                    },
                    line:{
                        color:colScheme[(key) % colScheme.length],
                    },
                    mode: "lines",
                    name: "B" + batches[key].name+": "+batches[key].userName,
                    type: "scatter",
                    hoverinfo: "name+x",

                };
            }
        });
        scaleTab = document.getElementById("scaleList")
        if (scale_bool == "true") {

            text += "</tbody></table>"
            scaleTab.innerHTML = text
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        } else {
            scaleTab.innerHTML = ""
            scaleTab.setAttribute("style", "overflow-y:scroll; height:80px; width:185px;")
        }




        data_l = [];
        data_l2 = [];

        Object.keys(data).forEach(function (key, index) {



            data_l.push(data[key])
            data_l2.push(data2[key])

        });



        data_hm = CIOverlap(batches)
        Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

        additional = (maxWL - minWL) * 0.05
        layoutOL.xaxis.range = myPlot2.layout.xaxis.range


    }
})

var errorFlag;
var wl_range = [-1, 999999]
var minWL = -1;
var maxWL = 999999;
var cur_wlskip = 0;
var noiseWeighting = 1;
var batchesOrig = {}
var ticks = {}
var inactive = []
var settings = {} // to hold settings from previous session to restore everything automatically.

var buffer = {}

var buff_cd_arr = [];
var buff_wl_arr = [];
var buff_f_arr = [];


function readBufferFiles(evt) {

    var files = evt.target.files;

    let id = String(batchCount)
    buff_cd_arr = [];
    buff_wl_arr = [];
    buff_f_arr = [];
    if (files) {

        let datCount = 0;
        buffer[id] = {
            'files': {},
            'cd': [],
            'wl': [],
            'mean': [],
            'fileList': []
        };

        document.getElementById("bufferNumber").innerHTML = "<small>" + files.length + " Buffer Files</small>"

        for (var i = 0; i < files.length; i++) {

            f = files[i]

            var r = new FileReader();
            r.onload = (function (f) {
                return function (e) {
                    contents = e.target.result.split("\n");


                    if (document.getElementById("unit-mre").checked == true) {

                        buffer[id]["unit"] = "mre"
                    } else if (document.getElementById("unit-de").checked == true) {

                        buffer[id]["unit"] = "de"
                    } else if (document.getElementById("unit-mach").checked == true) {
                        buffer[id]["unit"] = "mach"
                        if (document.getElementById("conc").value != "") {
                            buffer[id]["conc"] = parseFloat(document.getElementById("conc").value)
                        } else {
                            return (alert("If using machine units, you must supply a concentration for your sample."))
                        }
                        if (document.getElementById("pathl").value != "") {
                            buffer[id]["pl"] = parseFloat(document.getElementById("pathl").value)
                        } else {
                            return (alert("If using machine units, you must supply a path length for your sample."))
                        }
                        if (document.getElementById("mrw").value != "") {
                            buffer[id]["mrw"] = parseFloat(document.getElementById("mrw").value)
                        } else {
                            return (alert("If using machine units, you must supply a MRW for your sample."))
                        }



                    }



                    let regex_numbers = /\-*\d+\.*\d+/g
                    let regex_letters = /[A-DF-Za-df-z]/g
                    let cd = [];
                    let wl = [];

                    let datStart = false;
                    datCount = 0
                    for (j = 0; j < contents.length; j++) {

                        if (contents[j].trim().match(/^\d/) == null) {

                            if (cd.length > 0) {

                                if (datCount > 0) {
                                    buffer[id]["files"][f.name + "-" + (1 + datCount)] = { "cd": [], "wl": [] };
                                    buffer[id]["files"][f.name + "-" + (1 + datCount)].cd = cd
                                    buffer[id]["files"][f.name + "-" + (1 + datCount)].wl = wl
                                    buff_f_arr.push(f.name + "-" + (1 + datCount))
                                    buff_cd_arr.push(cd)
                                    buff_wl_arr.push(wl)
                                } else {
                                    buffer[id]["files"][f.name] = { "cd": [], "wl": [] };
                                    buffer[id]["files"][f.name].cd = cd
                                    buffer[id]["files"][f.name].wl = wl
                                    buff_f_arr.push(f.name)
                                    buff_cd_arr.push(cd)
                                    buff_wl_arr.push(wl)
                                }

                                datCount += 1
                                cd = []
                                wl = []
                            }





                        } else if (!contents[j].split(/[\s\t\,\:]+/).some(isNaN) && contents[j].split(/[\s\t\,\:]+/)[0] != "") {//regex_numbers.test(contents[j])===true && regex_letters.test(contents[j])===false && datStart===true){

                            line = contents[j].split(/[\s\t\,\:]+/)

                            cd_tmp = parseFloat(line[1])

                            /* if(buffer.unit=="mre"){
                                cd_tmp=cd_tmp/3298
                            }
                            if(buffer.unit=="mach"){
                                cd_tmp=cd_tmp*((0.1*buffer.mrw)/(buffer.pl*buffer.conc))/3298
                            } */

                            cd.push(cd_tmp)
                            wl.push(parseFloat(line[0]))

                        }
                    }
                    if (cd.length > 0) {
                        if (datCount > 0) {
                            buffer[id]["files"][f.name + "-" + (1 + datCount)] = { "cd": [], "wl": [] };
                            buffer[id]["files"][f.name + "-" + (1 + datCount)].cd = cd
                            buffer[id]["files"][f.name + "-" + (1 + datCount)].wl = wl
                            buff_f_arr.push(f.name + "-" + (1 + datCount))
                            buff_cd_arr.push(cd)
                            buff_wl_arr.push(wl)
                        } else {

                            buffer[id]["files"][f.name] = { "cd": [], "wl": [] };
                            buffer[id]["files"][f.name].cd = cd
                            buffer[id]["files"][f.name].wl = wl
                            buff_f_arr.push(f.name)


                            buff_cd_arr.push(cd)
                            buff_wl_arr.push(wl)
                        }



                    }
                    buffer[id].fileList = buff_f_arr
                    buffer[id].cd = buff_cd_arr
                    buffer[id].wl = buff_wl_arr

                }

            })(f);

            r.readAsText(f);

        }





    } else {
        document.getElementById("bufferNumber").innerHTML = "<small>None</small>"
        alert("Failed to load files");
    }

    clearFileInput(document.getElementById('fileinput'));

}

function mainProcess(batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors, final = true) {
    console.log(id)
    batchCount++

    batch.mre_sel = false
    batch.de_sel = true
    batch.prev_unit = "de"




    batch.wlskip = wl_arr[0][0] - wl_arr[0][1]

    if (batch.wlskip > cur_wlskip) {
        cur_wlskip = batch.wlskip
    }



    ticks[id] = Array(f_arr.length).fill(true)

    if (final) {
        slider_wl.noUiSlider.set([wl_range[0], wl_range[1]])
    }



    mean = math.mean(cd_arr, 0)
    batch["false"].mean = mean
    mean_z = math.subtract(mean.reverse(), mean.reverse()[0])
    mean_sc = math.divide(mean_z, math.max((mean_z)))
    batch["true"].mean = mean_sc
    batch.name = id
    batch["wl"] = wl_arr[0]
    batch["fileList"] = f_arr

    std = []
    stderr = []
    confInt = []
    mad = []
    median = []

    std_sc = []
    stderr_sc = []
    confInt_sc = []

    std_NOISE = []
    mean_corrected_NOISE = []

    let cd_arr_t_sc = transpose((math.divide(cd_arr, math.max(math.abs(mean)))))
    batch["true"]["tcdarr"] = cd_arr_t_sc

    let cd_arr_t = transpose(cd_arr)
    batch["false"]["tcdarr"] = cd_arr_t

    for (k = 0; k < cd_arr_t.length; k++) {
        mean_corrected_NOISE.push(math.dotDivide(cd_arr_t[k], math.abs(math.mean(cd_arr_t[k]))))
        std_NOISE.push(math.std(mean_corrected_NOISE[k]))
        mad.push(math.std(cd_arr_t[k]))
        median.push(math.median(cd_arr_t[k]))
        s = math.std(cd_arr_t[k])
        std.push(s)
        confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

        stderr.push((s / (math.sqrt(cd_arr_t[k].length))))

        s = math.std(cd_arr_t_sc[k])
        std_sc.push(s)
        confInt_sc.push(jStat.tci(0, alpha, cd_arr_t_sc[k])[1])

        stderr_sc.push((s / (math.sqrt(cd_arr_t_sc[k].length))))

    }


    batch.median = median
    batch.mad = mad

    batch["false"].std = std
    batch["false"].stderr = stderr
    batch["false"].snr = math.dotDivide(math.abs(mean), std)
    batch["true"].std = std_sc
    batch["true"].stderr = stderr_sc
    batch["true"].snr = math.dotDivide(math.abs(mean_sc), std_sc)

    batch.name = id

    batch["false"].confInt = confInt //math.divide(confInt, math.max(math.abs(mean)))
    batch["false"].cdarr = transpose(batch["false"].tcdarr)
    batch["true"].confInt = confInt_sc //math.divide(confInt, math.max(math.abs(mean)))
    batch["true"].cdarr = transpose(batch["true"].tcdarr)

    bkey_old = String(id)
    getOutliers(batch, f_arr)
    drawBufferPlot(String(id))

    unitSele = ``

    unitSele += `</tr><table>`

    document.getElementById('batchFileList').innerHTML = "<table style='width:95%'><tbody>" + batch.outliers_c.join("") + "</tbody</table"
    document.getElementById("batchFileListTitle").innerHTML = "<table><tr><td><h6>B" + String(id) + ": "+batch.userName + " Summary</h6></td>" + unitSele + "<hr>"

    bkey = String(id)
    batches[String(id)] = (batch);
    batchesOrig[String(id)] = jQuery.extend(true, {}, batch);

    let raw = batch.files
    data_preview = []

    for (i = 0; i < batchesOrig[String(id)].fileList.length; i++) {
        if (f_arr.includes(batchesOrig[String(id)].fileList[i])) {
            data_preview.push({
                x: raw[batchesOrig[String(id)].fileList[i]].wl,
                y: raw[batchesOrig[String(id)].fileList[i]].cd,

                mode: "lines",
                name: batchesOrig[String(id)].fileList[i],
                type: "scatter",
                hoverinfo: "name+x+y",
                line: {
                    color: colScheme.slice(1)[i]
                }
            });
        }

    }

    smSD = sGolayG(batch["false"].std, math.abs(raw[f_arr[0]].wl[0] - raw[f_arr[0]].wl[1]), { derivative: 0, windowSize: 19, polynomial: 2 })


    noise = noiseModel(smSD)

    batch.noise = noise

    data_preview.push({
        x: raw[f_arr[0]].wl,
        y: noise,
        fill: 'tozeroy',
        mode: "lines",
        name: "Noise",
        type: "scatter",
        hoverinfo: "name+x+y",
        line: {
            color: "rgb(255, 20, 20)",
            width: 1
        },
        yaxis: 'y2',

    });

    data_preview.push({
        x: raw[f_arr[0]].wl,
        y: Array(noise.length).fill(5),

        mode: "lines",
        name: "Noise Cutoff",
        type: "scatter",
        hoverinfo: "name",
        line: {
            color: "rgb(20, 20, 255)",
            width: 2
        },
        yaxis: 'y2',

    });
    data_preview.push({
        x: raw[f_arr[0]].wl,
        y: Array(noise.length).fill(8),

        mode: "lines",
        name: "Threshold",
        type: "scatter",
        hoverinfo: "name",
        line: {
            color: "rgb(255,255,255)",
            width: 2,

        },
        opacity: 0,
        yaxis: 'y2',

    });

    wl_slice = [batch.wl.indexOf(parseFloat(wl_range[1])), batch.wl.indexOf(parseFloat(wl_range[0])) + 1]


    wl_shapes = [
        {
            type: "rect",
            xref: 'x',
            yref: 'paper',
            x0: math.min(raw[f_arr[0]].wl),
            y0: 0,
            x1: wl_range[0],
            y1: 1,
            fillcolor: "#8a8c8e",
            opacity: 0.3,
            line: {
                width: 0
            }
        },
        {
            type: "rect",
            xref: 'x',
            yref: 'paper',
            x0: wl_range[1],
            y0: 0,
            x1: math.max(raw[f_arr[0]].wl),
            y1: 1,
            fillcolor: "#8a8c8e",
            opacity: 0.3,
            line: {
                width: 0
            }
        }
    ];

    layoutPre.shapes = wl_shapes


    Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })




    sFactors = getScaling(batches)





    wl_slice = [batch.wl.indexOf(parseFloat(wl_range[1])), batch.wl.indexOf(parseFloat(wl_range[0])) + 1]

    sumPNPC = []

    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]





        stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
        diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
        positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);



        batches[key].noisePC = positiveNumbersPC;





        batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
        if (inactive.includes(key) == false) {
            sumPNPC.push(positiveNumbersPC)
            data[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },

                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
        }
    });

    if (sumPNPC.length > 0) {
        noiseWeighting = 1 - (math.mean(sumPNPC))
    } else {
        noiseWeighting = 1
    }

    data_l = [];
    data_l2 = [];




    document.getElementById("noise-pc").innerHTML = String((batches[String(id)].noisePC * 100).toFixed(1)) + "%"
    document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
    document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
    document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
    
    Object.keys(data).forEach(function (key, index) {

        if(inactive.includes(key) == false){
            data_l.push(data[key])
            data_l2.push(data2[key])

        }

        
    });
    index_ofWL = batches[String(id)].wl.indexOf(math.mean(wl_range))


    batches_l = []

    Object.keys(batches).forEach(function (key, index) {
        if (!inactive.includes(key)) {
            batches_l.push(batches[key])
        }
    });
    console.log(final)
    if (final) {
        data_hm = CIOverlap(batches, final)
    }

    yrange_tmp = [batches[String(id)]["true"].mean[index_ofWL] - batches[String(id)]["true"].confInt[index_ofWL] * 4, batches[String(id)]["true"].mean[index_ofWL] + batches[String(id)]["true"].confInt[index_ofWL] * 4]
    xrange_tmp = [parseInt(math.mean(wl_range)) - 4, parseInt(math.mean(wl_range)) + 4]

    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

    additional = (maxWL - minWL) * 0.05
    layoutOL.xaxis.range = myPlot2.layout.xaxis.range

    flEl = document.getElementById("filelist");
    newDiv = document.createElement("div")
    newDiv.id = id + "-div"

    newTa = document.createElement("table")
    newTa.setAttribute("class", "table-hover")
    newTa.setAttribute("style", "width:100%")
    newTab = document.createElement("tbody")
    newTrow = document.createElement("tr")
    newTD1 = document.createElement("td")
    newTD1.setAttribute("style", "width:60px")
    newTD1.id = id + '-tab'
    newTD1.onclick = function () { getBatchInfo(this) }
    newTD2 = document.createElement("td")
    newBtn = document.createElement("button")
    newBtn.id = id
    newBtn.setAttribute('class', 'btn btn-primary')
    newBtn.setAttribute('style', 'border: solid; border-color:white;border-width:2px; font-weight:bold')
    newBtn.addEventListener('click', removeBatch, false);
    newTD1.innerHTML = ("<span id='ball-" + id + "' class='dot' style='background-color:" + colScheme[Object.keys(batches).length % colScheme.length] + "; height:15px;width:15px;'></span><b> B" + id +  "</b>");

    newTD1_5 = document.createElement("td")
    newTD1_5.setAttribute("style", "width:180px")
    newTD1_5.id = id + '-tabname'
    newTD1_5.onclick = function () { getBatchInfo(this) }
    newTD1_5.innerHTML=batches[id].userName

    newContent = document.createTextNode("X");
    
    newBtn.appendChild(newContent);

    brk = document.createElement("br");
    brk.id = id + "-brk"
    newTD2.appendChild(newBtn);

    newTD2_5 = document.createElement("td")
    newBtnName = document.createElement("button")
    newBtnName.id = "name-"+id
    newBtnName.setAttribute('class', 'btn btn-primary')
    newBtnName.setAttribute('style', 'border: solid; border-color:white;border-width:2px; font-weight:bold')
    newBtnName.addEventListener('click', nameChange, false);
    newContent = document.createTextNode("ID");
    newBtnName.appendChild(newContent);
    newTD2_5.appendChild(newBtnName);


    newTD4 = document.createElement("td")


    newTD4.innerHTML = '<img id="batchDown-' + id + '" style="cursor: pointer;width:20px;height:20px;" src="data-transfer-download.svg">'

    newTD4.addEventListener('click', function (e) {
        bno = e.target.id.split("-")[1]
        downloadDCF(batches[bno])
    })

    newTD3 = document.createElement("td")
    newCheck = document.createElement("input")
    newCheck.type = "checkbox";
    if(inactive.includes(id)){
        newCheck.checked = false
    }else{
        newCheck.checked = true
    }
    
    newCheck.id = "check-batch-" + id;

    newCheck.addEventListener('click', function (e) {
        if (this.checked) {


            inactive = inactive.filter(ia => ia != this.id.split("-")[2])

            sumPNPC = []
            data = {}
            data["0"] = {
                x: [],
                y: [],


                mode: "lines",
                name: "Premium",
                type: "scatter",
                hoverinfo: "name+x",


            };
            data2 = {}
            data2["0"] = {
                x: [],
                y: [],


                mode: "lines",
                name: "Premium",
                type: "scatter",
                hoverinfo: "name+x",


            };
            sFactors = getScaling(batches)

            Object.keys(batches).forEach(function (key, index) {

                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

                stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
                diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
                positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);


                batches[key].noisePC = positiveNumbersPC;




                batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
                if (inactive.includes(key) == false) {

                    sumPNPC.push(positiveNumbersPC)
                    data[key] = {
                        x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        mode: "lines",
                        name: "B" + batches[key].name+": "+batches[key].userName,
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                    data2[key] = {
                        x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        error_y: {
                            type: 'data',
                            array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                            visible: true
                        },

                        mode: "lines",
                        name: "B" + batches[key].name+": "+batches[key].userName,
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                } else {
                    data[key] = {
                        x: [],
                        y: [],


                        mode: "lines",
                        name: "Premium",
                        type: "scatter",
                        hoverinfo: "name+x",

                    };
                    data2[key] = {
                        x: [],
                        y: [],


                        mode: "lines",
                        name: "Premium",
                        type: "scatter",
                        hoverinfo: "name+x",

                    };
                }
            });

            if (sumPNPC.length > 0) {
                noiseWeighting = 1 - (math.mean(sumPNPC))
            } else {
                noiseWeighting = 1
            }

            data_l = [];
            data_l2 = [];
            if (bkey != 0) {
                document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
                document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
                document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
                document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
            }


            Object.keys(data).forEach(function (key, index) {



                data_l.push(data[key])
                data_l2.push(data2[key])

            });



            batches_l = []

            Object.keys(batches).forEach(function (key, index) {
                if (!inactive.includes(key)) {
                    batches_l.push(batches[key])
                }
            });



            data_hm = CIOverlap(batches)




            Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
            Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
            layoutOL.xaxis.range = myPlot2.layout.xaxis.range

        } else if (Object.keys(batches).length - inactive.length > 1) {

            inactive.push(this.id.split("-")[2])

            sumPNPC = []
            data = {}
            data["0"] = {
                x: [],
                y: [],


                mode: "lines",
                name: "Premium",
                type: "scatter",
                hoverinfo: "name+x",

            };
            data2 = {}
            data2["0"] = {
                x: [],
                y: [],


                mode: "lines",
                name: "Premium",
                type: "scatter",
                hoverinfo: "name+x",

            };

            sFactors = getScaling(batches)
            Object.keys(batches).forEach(function (key, index) {


                wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

                stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
                diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
                positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);


                batches[key].noisePC = positiveNumbersPC;




                batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
                if (inactive.includes(key) == false) {

                    sumPNPC.push(positiveNumbersPC)
                    data[key] = {
                        x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        mode: "lines",
                        name: "B" + batches[key].name+": "+batches[key].userName,
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                    data2[key] = {
                        x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                        error_y: {
                            type: 'data',
                            array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                            visible: true
                        },

                        mode: "lines",
                        name: "B" + batches[key].name+": "+batches[key].userName,
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                } else {
                    data[key] = {
                        x: [],
                        y: [],


                        mode: "lines",
                        name: "Premium",
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                    data2[key] = {
                        x: [],
                        y: [],


                        mode: "lines",
                        name: "Premium",
                        type: "scatter",
                        hoverinfo: "name+x",
                        line:{
                            color:colScheme[(key) % colScheme.length],
                        },
                    };
                }
            });

            if (sumPNPC.length > 0) {
                noiseWeighting = 1 - (math.mean(sumPNPC))
            } else {
                noiseWeighting = 1
            }

            data_l = [];
            data_l2 = [];
            if (bkey != 0) {
                document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
                document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
                document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
                document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
            }


            Object.keys(data).forEach(function (key, index) {



                data_l.push(data[key])
                data_l2.push(data2[key])

            });



            batches_l = []

            Object.keys(batches).forEach(function (key, index) {
                if (!inactive.includes(key)) {
                    batches_l.push(batches[key])
                }
            });

            data_hm = CIOverlap(batches)




            Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
            Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
            layoutOL.xaxis.range = myPlot2.layout.xaxis.range

        } else {
            this.checked = true
        }

    })

    newTD3.appendChild(newCheck)

    newTrow.appendChild(newTD1)
    newTrow.appendChild(newTD1_5)
    newTrow.appendChild(newTD2_5)
    newTrow.appendChild(newTD2)
    newTrow.appendChild(newTD4)
    newTrow.appendChild(newTD3)
    newTab.appendChild(newTrow)
    newTa.appendChild(newTab)
    newDiv.appendChild(newTa)
    flEl.appendChild(newDiv)

    return (batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors)
}

var bk;

function nameChange(e){
    console.log(e.target.id.slice(5))
    bk=e.target.id.slice(5);
    document.getElementById("batchNameChange").value=batches[bk].userName
    $('#bnameModal').modal('show')
    
}

document.getElementById("saveBatchNameButton").addEventListener("click", function(e){
    tmp_name=document.getElementById("batchNameChange").value
    console.log(tmp_name)
    tmp_name=tmp_name.trim()
    tmp_name=tmp_name.replace(/(<([^>]+)>)/gi, "");
    errorNameP=document.getElementById("batchNameError")
    let nameTarget=document.getElementById(bk+"-tabname")
    if(tmp_name!=""){
        
        errorNameP.innerHTML=""
        $('#bnameModal').modal('hide')
        nameTarget.innerHTML=tmp_name
        batches[bk].userName=tmp_name
        data[bk].name=data[bk].name+tmp_name
        data2[bk].name=data2[bk].name+tmp_name
        if(bkey==bk){
            document.getElementById("batchFileListTitle").innerHTML = "<table><tr><td><h6>B" + String(bkey) + ": "+batches[bkey].userName + " Summary</h6></td>"+ unitSele + "<hr>"
        }
        
        CIOverlap(batches)
        data_l = [];
        data_l2 = [];

        Object.keys(data).forEach(function (key, index) {



            data_l.push(data[key])
            data_l2.push(data2[key])

        });



        data_hm = CIOverlap(batches)
        Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

    }else{
        errorNameP.innerHTML="Name cannot be blank."
    }

    
})

function areaUnderCurve(spec) {

    let spec_abs = math.abs(spec)
    area = 0
    for (j = 0; j < spec_abs.length - 1; j++) {
        area += (spec_abs[j] + spec_abs[j + 1])
    }
    return (area)
}

var currBatchName;

function readMultipleFiles(evt) {
    document.getElementById("loadingImg").hidden = false
    $('#Modal').modal('hide')

    setTimeout(function () {

        document.getElementById("bufferNumber").innerHTML = "<small>None</small>"
        var files = evt.target.files;
        var numFiles_orig = 0;
        var numFiles = 0;
        var datCount
        let id = String(batchCount)
        scale_bool = String(scale_chk.checked)

        currBatchName=document.getElementById("batchNameBox").value

        cd_arr = Array()
        wl_arr = Array()
        f_arr = Array()
        errorFlag = false;
        errorFileCount = 0;
        dcs_flag = false
        if (files) {

            batch = {
                'userName':currBatchName,
                'files': {},
                'false': { 'area': [] },
                'true': { 'area': [] },
                'fileList': []
            };

            for (var i = 0; i < files.length; i++) {
                f = files[i]

                var r = new FileReader();
                r.onload = (function (f) {
                    return function (e) {
                        contents = e.target.result.split("\n");

                        numFiles_orig += 1

                        datCount = 0



                        if (f.name.endsWith(".tcf") || f.name.endsWith(".tcs")) {
                            return (alert("You have submitted a ThermoCompare file (.tcs/.tcf) - use the Thermocompare tool to analyse this data. Upload a .dcs/.dcf file to analyse using DichroCompare."))
                        } else if (f.name.endsWith(".dcf")) {

                            let cd = []
                            let wl = []
                            for (j = 0; j < contents.length; j++) {
                                if (contents[j].startsWith("@!BUFFEROBJ")) {
                                    set_info = contents[j].slice(2).split(":")

                                    buffer[id] = JSON.parse(set_info.slice(1).join(":"))


                                }
                                else if (contents[j].startsWith(">")) {
                                    if (cd.length > 0) {

                                        batch["files"][fn] = { "cd": [], "wl": [] };
                                        batch["files"][fn].cd = cd
                                        batch["files"][fn].wl = wl
                                        f_arr.push(fn)
                                        cd_arr.push(cd)
                                        wl_arr.push(wl)
                                        function areaUnderCurve(spec) {


                                            let spec_abs = math.abs(spec)
                                            area = 0
                                            for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                                area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                            }
                                            return (area)
                                        }

                                        batch["false"]["area"].push(areaUnderCurve(cd))
                                        datStart = false

                                        numFiles += 1
                                        fn = contents[j].trim().split("").slice(1, (contents[j]).length).join('')
                                        cd = []
                                        wl = []
                                    } else {
                                        fn = contents[j].trim().split("").slice(1, (contents[j]).length).join('')
                                        cd = []
                                        wl = []
                                    }
                                } else if (contents[j] != "") {
                                    wl.push(parseFloat(contents[j].trim().split("\t")[0]))
                                    cd.push(parseFloat(contents[j].trim().split("\t")[1]))
                                }
                            }
                            batch["files"][fn] = { "cd": [], "wl": [] };
                            batch["files"][fn].cd = cd
                            batch["files"][fn].wl = wl
                            f_arr.push(fn)
                            cd_arr.push(cd)
                            wl_arr.push(wl)
                            function areaUnderCurve(spec) {


                                let spec_abs = math.abs(spec)
                                area = 0
                                for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                    area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                }
                                return (area)
                            }

                            batch["false"]["area"].push(areaUnderCurve(cd))
                            datStart = false

                            numFiles += 1


                        } else if (f.name.endsWith(".dcs")) {
                            minWL = 0
                            maxWL = 9999999
                            document.getElementById("currentDCSName").innerHTML=f.name
                            Object.keys(batches).forEach(function (key, index) {
                                document.getElementById(key + "-div").remove()
                            })
                            batches = {}
                            data = {}
                            data2 = {}
                            data["0"] = {
                                x: [],
                                y: [],


                                mode: "lines",
                                name: "Premium",
                                type: "scatter",
                                hoverinfo: "name+x",


                            };
                            data2 = {}
                            data2["0"] = {
                                x: [],
                                y: [],


                                mode: "lines",
                                name: "Premium",
                                type: "scatter",
                                hoverinfo: "name+x",


                            };
                            batchCount = 1
                            inactive = []

                            batchCount2 = parseInt(batchCount)
                            tmp_batches = {}
                            tmp_numFiles = {}
                            tmp_numFilesOrig = {}
                            tmp_cdarrs = {}
                            tmp_wlarrs = {}
                            tmp_fnarrs = {}
                            batch2 = {
                                'files': {},
                                'false': { 'area': [] },
                                'true': { 'area': [] },
                                'fileList': []
                            };
                            let cd = []
                            let wl = []
                            tmpfileList = []

                            for (j = 0; j < contents.length; j++) {

                                if (contents[j].startsWith("@!")) {
                                    set_info = contents[j].slice(2).split(":")
                                    settings[set_info[0]] = set_info[1]


                                    if (set_info[0] == "BUFFEROBJ") {

                                        buffertmp = JSON.parse(set_info.slice(1).join(":"))
                                        buffer = {}
                                        Object.keys(buffertmp).forEach(function (key, index) {
                                            buffer[String(index + 1)] = buffertmp[key]
                                        });
                                    }
                                    
                                } else if (contents[j].startsWith("@>ACTIVE")) {

                                    tmpfileList = JSON.parse(contents[j].slice(2).split(":")[1])

                                } else if (contents[j].startsWith("#")) {
                                    currBatchName=contents[j].slice(11) // so batches have names they were saved with
                                    batch2["files"][fn] = { "cd": [], "wl": [] };
                                    batch2["files"][fn].cd = cd
                                    batch2["files"][fn].wl = wl.slice()
                                    batch2["fileList"] = tmpfileList
                                    batch2["userName"]=currBatchName;
                                    f_arr.push(fn)
                                    cd_arr.push(cd)
                                    wl_arr.push(wl)
                                    function areaUnderCurve(spec) {


                                        let spec_abs = math.abs(spec)
                                        area = 0
                                        for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                            area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                        }
                                        return (area)
                                    }

                                    batch2["false"]["area"].push(areaUnderCurve(cd))
                                    datStart = false

                                    

                                    cd = []
                                    wl = []


                                    tmp_batches[batchCount2] = batch2
                                    tmp_numFiles[batchCount2] = numFiles
                                    tmp_numFilesOrig[batchCount2] = numFiles_orig
                                    tmp_cdarrs[batchCount2] = cd_arr
                                    tmp_wlarrs[batchCount2] = wl_arr
                                    tmp_fnarrs[batchCount2] = f_arr
                                    batchCount2 += 1

                                    numFiles_orig = 0;
                                    numFiles = 0;



                                    scale_bool = settings.SCBOOL
                                    document.getElementById("scale").checked = JSON.parse(scale_bool)
                                    dev_t = settings.DEV
                                    document.getElementById("devThresh").value = dev_t

                                    if("NAME" in settings){
                                        runname = settings.NAME

                                        if(runname!=""){
                                            document.getElementById("runName").value=runname
                                            document.getElementById("currentRunName").innerHTML=runname
                                        }else{
                                            runname="None"
                                            document.getElementById("runName").value=runname
                                            document.getElementById("currentRunName").innerHTML="None"
                                        }
                                    
                                        
                                    }else{
                                        runname="None"
                                        document.getElementById("runName").value=runname
                                        document.getElementById("currentRunName").innerHTML="None"
                                    }
                                    

                                    cd = []
                                    wl = []


                                    cd_arr = Array()
                                    wl_arr = Array()
                                    f_arr = Array()
                                    errorFlag = false;
                                    errorFileCount = 0;

                                    batch2 = {
                                        'files': {},
                                        'false': { 'area': [] },
                                        'true': { 'area': [] },
                                        'fileList': []
                                    };

                                } else if (contents[j].startsWith(">")) {

                                    if (cd.length > 0) {
                                        numFiles += 1
                                        batch2["files"][fn] = { "cd": [], "wl": [] };
                                        batch2["files"][fn].cd = cd
                                        batch2["files"][fn].wl = wl.slice()
                                        f_arr.push(fn)
                                        cd_arr.push(cd)
                                        wl_arr.push(wl)
                                        function areaUnderCurve(spec) {


                                            let spec_abs = math.abs(spec)
                                            area = 0
                                            for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                                area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                            }
                                            return (area)
                                        }

                                        batch2["false"]["area"].push(areaUnderCurve(cd))
                                        datStart = false


                                        fn = contents[j].trim().split("").slice(1, (contents[j]).length).join('')
                                        cd = []
                                        wl = []
                                    } else {
                                        numFiles += 1
                                        fn = contents[j].trim().split("").slice(1, (contents[j]).length).join('')
                                        cd = []
                                        wl = []
                                    }
                                } else if (contents[j].startsWith("!") == false) {
                                    wl.push(parseFloat(contents[j].trim().split("\t")[0]))
                                    cd.push(parseFloat(contents[j].trim().split("\t")[1])) //POTENTIAL ISSUE CHECK THIS OUT - different batch no.
                                } else if (contents[j].startsWith("!")) {
                                    dcs_flag = true

                                    Object.keys(tmp_batches).forEach(function (key2, index2) {
                                        batchCount = parseInt(key2)
                                        id = key2
                                        batch = tmp_batches[key2]

                                        numFiles = tmp_numFiles[key2]
                                        numFiles_orig = tmp_numFilesOrig[key2]
                                        i = numFiles_orig
                                        cd_arr = tmp_cdarrs[key2]
                                        wl_arr = tmp_wlarrs[key2]
                                        f_arr = tmp_fnarrs[key2]
                                        if (key2 < Object.keys(tmp_batches).length) {

                                            if (cd_arr[numFiles - 1].some(isNaN) || wl_arr[numFiles - 1].some(isNaN) || cd_arr[numFiles - 1].length === 0) {

                                                errorFlag = true;
                                                errorFileCount += 1;

                                                delete batches[id]
                                                batchCount -= 1
                                                if (batchCount < 1) {
                                                    batchCount = 1
                                                }
                                                return (alert("There was a problem parsing your file: " + f.name + ". Please ensure your files follow the formats specified in the Help section."))


                                            } else {


                                                if (i == numFiles_orig && errorFlag === false) {

                                                    if (cd_arr.length < 2) {
                                                        errorFlag = true;
                                                        delete batches[id]
                                                        batchCount -= 1
                                                        if (batchCount < 1) {
                                                            batchCount = 1
                                                        }
                                                        return (alert("You appear to have only uploaded a single spectra into this batch. The analysis requires a minimum of 2 spectra to work."))
                                                    }


                                                    
                                                    if (math.min(wl_arr) > minWL) {
                                                        minWL = math.min(wl_arr)
                                                    }
                                                    if (math.max(wl_arr) < maxWL) {
                                                        maxWL = math.max(wl_arr)
                                                    }

                                                    zero_numb1.max = maxWL
                                                    zero_numb1.min = minWL
                                                    zero_numb1.value = settings.ZERO1
                                                    zero_wl1 = settings.ZERO1
                                                    zero_numb2.max = maxWL
                                                    zero_numb2.min = minWL
                                                    zero_numb2.value = settings.ZERO2
                                                    zero_wl2 = settings.ZERO2
                                                    zero_bool = JSON.parse(settings.ZEROBOOL)
                                                    qcmode = JSON.parse(settings.QCBOOL)

                                                    refSetInd = JSON.parse(settings.REFSETIND)
                                                    if ("REFSETINDALL" in settings) {
                                                        refSetIndAll = []
                                                        for (i = 0; i < JSON.parse(settings.REFSETINDALL).length; i++) {
                                                            refSetIndAll.push(parseInt(JSON.parse(settings.REFSETINDALL)[i]))
                                                        }
                                                    } else {
                                                        refSetIndAll = []
                                                        for (i = 0; i < JSON.parse(settings.REFSETIND).length; i++) {
                                                            refSetIndAll.push(parseInt(JSON.parse(settings.REFSETIND)[i]))
                                                        }
                                                    }
                                                    refSetActive = JSON.parse(settings.REFSETACT)
                                                    refSetInd = []
                                                    for (i = 0; i < JSON.parse(settings.REFSETIND).length; i++) {
                                                        refSetInd.push(parseInt(JSON.parse(settings.REFSETIND)[i]))
                                                    }
                                                    refSet = []
                                                    for (i = 0; i < refSetIndAll.length; i++) {

                                                        refSet.push("" + (parseInt(refSetIndAll[i]) + 1))
                                                    }



                                                    document.getElementById("zeroData").checked = zero_bool
                                                    document.getElementById("qcmode-1").checked = qcmode

                                                    if (minWL === maxWL) {
                                                        return (alert("The spectra you have uploaded do not have overlapping wavelength ranges, so the analysis cannot be carried out."))
                                                    } else {
                                                        wl_range[0] = settings.MIN


                                                        wl_range[1] = settings.MAX
                                                        alpha = parseFloat(settings.ALPHA)


                                                        inactive = JSON.parse(settings.INACTIVE)

                                                        batches[id] = {}

                                                        slider_wl.removeAttribute('disabled');

                                                        slider_wl.noUiSlider.updateOptions({
                                                            range: {
                                                                'min': minWL,
                                                                'max': maxWL
                                                            },
                                                            tooltips: true,

                                                        })


                                                        setTimeout(console.log("rest"),1)
                                                        batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors = mainProcess(batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors, false)

                                                    }

                                                }
                                            }
                                        } else {

                                            if (cd_arr[numFiles - 1].some(isNaN) || wl_arr[numFiles - 1].some(isNaN) || cd_arr[numFiles - 1].length === 0) {

                                                errorFlag = true;
                                                errorFileCount += 1;

                                                delete batches[id]
                                                batchCount -= 1
                                                if (batchCount < 1) {
                                                    batchCount = 1
                                                }
                                                return (alert("There was a problem parsing your file: " + f.name + ". Please ensure your files follow the formats specified in the Help section."))


                                            } else {


                                                if (i == numFiles_orig && errorFlag === false) {
                                                    if (cd_arr.length < 2) {
                                                        errorFlag = true;
                                                        delete batches[id]
                                                        batchCount -= 1
                                                        if (batchCount < 1) {
                                                            batchCount = 1
                                                        }
                                                        return (alert("You appear to have only uploaded a single spectra into this batch. The analysis requires a minimum of 2 spectra to work."))
                                                    }


                                                    
                                                    if (math.min(wl_arr) > minWL) {
                                                        minWL = math.min(wl_arr)
                                                    }
                                                    if (math.max(wl_arr) < maxWL) {
                                                        maxWL = math.max(wl_arr)
                                                    }


                                                    zero_numb1.max = maxWL
                                                    zero_numb1.min = minWL
                                                    zero_numb1.value = settings.ZERO1
                                                    zero_wl1 = settings.ZERO1
                                                    zero_numb2.max = maxWL
                                                    zero_numb2.min = minWL
                                                    zero_numb2.value = settings.ZERO2
                                                    zero_wl2 = settings.ZERO2
                                                    zero_bool = JSON.parse(settings.ZEROBOOL)


                                                    document.getElementById("zeroData").checked = zero_bool

                                                    if (minWL === maxWL) {
                                                        return (alert("The spectra you have uploaded do not have overlapping wavelength ranges, so the analysis cannot be carried out."))
                                                    } else {
                                                        wl_range[0] = settings.MIN


                                                        wl_range[1] = settings.MAX
                                                        alpha = parseFloat(settings.ALPHA)


                                                        inactive = JSON.parse(settings.INACTIVE)

                                                        batches[id] = {}

                                                        slider_wl.removeAttribute('disabled');

                                                        slider_wl.noUiSlider.updateOptions({
                                                            range: {
                                                                'min': minWL,
                                                                'max': maxWL
                                                            },
                                                            tooltips: true,

                                                        })
                                                        setTimeout(console.log("rest"),1)
                                                        batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors = mainProcess(batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors)

                                                        Object.keys(batches).forEach(function (key, index) {


                                                            document.getElementById("" + key + "-div").setAttribute("style", "background-color: transparent")

                                                        });

                                                        document.getElementById("" + id + "-div").setAttribute("style", "background-color:#dbdbdb ")

                                                        document.getElementById("plotly-divRaw").setAttribute('style', "display:visible")
                                                        document.getElementById("plotly-divHmTrend").setAttribute('style', "display:visible")
                                                        document.getElementById("batchFileList").setAttribute('style', "overflow-y:scroll; height:280px; width:100%; display:visible")
                                                        document.getElementById("batchFileListTitle").setAttribute('style', "display:visible")
                                                        document.getElementById("summary").setAttribute('style', "display:visible;border-left: 1px solid #c8caca;")
                                                    }

                                                }
                                            }
                                        }
                                    })

                                    refSetInd = JSON.parse(settings.REFSETIND)
                                    if ("REFSETINDALL" in settings) {
                                        refSetIndAll = []
                                        for (i = 0; i < JSON.parse(settings.REFSETINDALL).length; i++) {
                                            refSetIndAll.push(parseInt(JSON.parse(settings.REFSETINDALL)[i]))
                                        }
                                    } else {
                                        refSetIndAll = []
                                        for (i = 0; i < JSON.parse(settings.REFSETIND).length; i++) {
                                            refSetIndAll.push(parseInt(JSON.parse(settings.REFSETIND)[i]))
                                        }
                                    }
                                    refSetActive = JSON.parse(settings.REFSETACT)
                                    refSetInd = []
                                    for (i = 0; i < JSON.parse(settings.REFSETIND).length; i++) {
                                        refSetInd.push(parseInt(JSON.parse(settings.REFSETIND)[i]))
                                    }
                                    refSet = []
                                    for (i = 0; i < refSetIndAll.length; i++) {

                                        refSet.push("" + (parseInt(refSetIndAll[i]) + 1))
                                    }
                                    data_hm = CIOverlap(batches)
                                    console.log("DCS loop count")

                                    return ("hello")
                                }
                            }


                        } else {

                            batch["unit"]="Not Specified"
                            batch["conc"]="Not Specified"
                            batch["pl"]="Not Specified"
                            batch["mrw"]="Not Specified"

                            if (document.getElementById("unit-mre").checked == true) {

                                batch["unit"] = "mre"
                            } else if (document.getElementById("unit-de").checked == true) {

                                batch["unit"] = "de"
                            } else if (document.getElementById("unit-mach").checked == true) {
                                batch["unit"] = "mach"
                                if (document.getElementById("conc").value != "") {
                                    batch["conc"] = parseFloat(document.getElementById("conc").value)
                                } else {
                                    return (alert("If using machine units, you must supply a concentration for your sample."))
                                }
                                if (document.getElementById("pathl").value != "") {
                                    batch["pl"] = parseFloat(document.getElementById("pathl").value)
                                } else {
                                    return (alert("If using machine units, you must supply a path length for your sample."))
                                }
                                if (document.getElementById("mrw").value != "") {
                                    batch["mrw"] = parseFloat(document.getElementById("mrw").value)
                                } else {
                                    return (alert("If using machine units, you must supply a MRW for your sample."))
                                }



                            }



                            let regex_numbers = /\-*\d+\.*\d+/g
                            let regex_letters = /[A-DF-Za-df-z]/g
                            let cd = [];
                            let wl = [];
                            let datStart = false;
                            if (Object.keys(buffer).includes(String(batchCount)) && buffer[batchCount].cd != undefined) {

                                buffer[batchCount].mean = math.mean(buffer[batchCount].cd, 0)
                            } else {
                                buffer[batchCount] = { mean: 0 }

                            }


                            for (j = 0; j < contents.length; j++) {

                                if (contents[j].trim().match(/^\d/) == null) {

                                    if (cd.length > 0) {
                                        //check buffer and CD are compatible
                                        buffok=true
                                        tmp_buff=0
                                        if("wl" in buffer[batchCount]){
                                        tmp_buff=[]
                                        for(let k=0;k<buffer[batchCount].wl[0].length;k++){
                                            if(wl.includes(buffer[batchCount].wl[0][k])){
                                                tmp_buff.push(buffer[batchCount].mean[k])
                                            }
                                        }
                                        if(tmp_buff.length == cd.length){
                                            buffok=true;
                                        }else{
                                            buffok=false;
                                        }
                                        }

                                        if(!buffok){
                                            buffer[batchCount]={}
                                            return (alert("Your buffer data does not encompass the full WL range required for your experimental data to be processed. Please check this and try again."))
                                        }

                                        cd_subtract = math.subtract(cd, tmp_buff)
                                        if (batch.unit == "mre") {
                                            cd_subtract = math.divide(cd_subtract, 3298)
                                        }
                                        if (batch.unit == "mach") {
                                            cd_subtract = math.multiply(cd_subtract, ((0.1 * batch.mrw) / (batch.pl * batch.conc)) / 3298)
                                        }
                                        if (datCount > 0) {
                                            batch["files"][f.name + "-" + (1 + datCount)] = { "cd": [], "wl": [] };
                                            batch["files"][f.name + "-" + (1 + datCount)].cd = cd_subtract
                                            batch["files"][f.name + "-" + (1 + datCount)].wl = wl
                                            f_arr.push(f.name + "-" + (1 + datCount))
                                            cd_arr.push(cd_subtract)
                                            wl_arr.push(wl)
                                        } else {
                                            batch["files"][f.name] = { "cd": [], "wl": [] };
                                            batch["files"][f.name].cd = cd_subtract
                                            batch["files"][f.name].wl = wl
                                            f_arr.push(f.name)
                                            cd_arr.push(cd_subtract)
                                            wl_arr.push(wl)
                                        }
                                        function areaUnderCurve(spec) {


                                            let spec_abs = math.abs(spec)
                                            area = 0
                                            for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                                area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                            }
                                            return (area)
                                        }

                                        batch["false"]["area"].push(areaUnderCurve(cd))
                                        datStart = false

                                        numFiles += 1
                                        datStart = true
                                        datCount += 1
                                        cd = []
                                        wl = []
                                    }

                                } else if (!contents[j].split(/[\s\t\,\:]+/).some(isNaN) && contents[j].split(/[\s\t\,\:]+/)[0] != "") {//regex_numbers.test(contents[j])===true && regex_letters.test(contents[j])===false && datStart===true){
                                    line = contents[j].split(/[\s\t\,\:]+/)

                                    cd_tmp = parseFloat(line[1])
                                    cd.push(cd_tmp)
                                    wl.push(parseFloat(line[0]))

                                }
                            }
                            if (cd.length > 0) {
                                //check buffer and CD are compatible
                                buffok=true
                                tmp_buff=0
                                if("wl" in buffer[batchCount]){
                                tmp_buff=[]
                                for(let k=0;k<buffer[batchCount].wl[0].length;k++){
                                    if(wl.includes(buffer[batchCount].wl[0][k])){
                                        tmp_buff.push(buffer[batchCount].mean[k])
                                    }
                                }
                                if(tmp_buff.length == cd.length){
                                    buffok=true;
                                }else{
                                    buffok=false;
                                }
                                }

                                if(!buffok){
                                    buffer[batchCount]={}
                                    return (alert("Your buffer data does not encompass the full WL range required for your experimental data to be processed. Please check this and try again."))
                                }
                                cd_subtract = math.subtract(cd, tmp_buff)
                                if (batch.unit == "mre") {
                                    cd_subtract = math.divide(cd_subtract, 3298)
                                }
                                if (batch.unit == "mach") {
                                    cd_subtract = math.multiply(cd_subtract, ((0.1 * batch.mrw) / (batch.pl * batch.conc)) / 3298)
                                }
                                if (datCount > 0) {
                                    batch["files"][f.name + "-" + (1 + datCount)] = { "cd": [], "wl": [] };
                                    batch["files"][f.name + "-" + (1 + datCount)].cd = cd_subtract
                                    batch["files"][f.name + "-" + (1 + datCount)].wl = wl
                                    f_arr.push(f.name + "-" + (1 + datCount))
                                    cd_arr.push(cd_subtract)
                                    wl_arr.push(wl)
                                } else {
                                    batch["files"][f.name] = { "cd": [], "wl": [] };
                                    batch["files"][f.name].cd = cd_subtract
                                    batch["files"][f.name].wl = wl
                                    f_arr.push(f.name)
                                    cd_arr.push(cd_subtract)
                                    wl_arr.push(wl)
                                }


                                function areaUnderCurve(spec) {


                                    let spec_abs = math.abs(spec)
                                    area = 0
                                    for (jjj = 0; jjj < spec_abs.length - 1; jjj++) {
                                        area += (spec_abs[jjj] + spec_abs[jjj + 1])
                                    }
                                    return (area)
                                }

                                batch["false"]["area"].push(areaUnderCurve(cd))
                                numFiles += 1

                                datCount += 1
                            }
                        }

                        if (cd_arr[numFiles - 1].some(isNaN) || wl_arr[numFiles - 1].some(isNaN) || cd_arr[numFiles - 1].length === 0) {

                            errorFlag = true;
                            errorFileCount += 1;

                            delete batches[id]
                            batchCount -= 1
                            if (batchCount < 1) {
                                batchCount = 1
                            }
                            return (alert("There was a problem parsing your file: " + f.name + ". Please ensure your files follow the formats specified in the Help section."))


                        } else {

                            if (i == numFiles_orig && errorFlag === false) {
                                if (cd_arr.length < 2) {
                                    errorFlag = true;
                                    delete batches[id]
                                    batchCount -= 1
                                    if (batchCount < 1) {
                                        batchCount = 1
                                    }
                                    return (alert("You appear to have only uploaded a single spectra into this batch. The analysis requires a minimum of 2 spectra to work."))
                                }


                                old_minWL = minWL + 0
                                old_maxWL = maxWL + 0
                                old_wl_range = wl_range.slice()
                                if (math.min(wl_arr) > minWL) {
                                    minWL = math.min(wl_arr)
                                }
                                if (math.max(wl_arr) < maxWL) {
                                    maxWL = math.max(wl_arr)
                                }

                                if (zero_wl1 > maxWL || zero_wl1 < minWL) {
                                    zero_numb1.value = maxWL
                                    zero_numb1.max = maxWL
                                    zero_numb1.min = minWL
                                    zero_wl1 = maxWL
                                }
                                if (zero_wl2 > maxWL || zero_wl2 < minWL) {
                                    zero_numb2.value = maxWL
                                    zero_numb2.max = maxWL
                                    zero_numb2.min = minWL
                                    zero_wl2 = maxWL
                                }
                                if (minWL >= wl_range[0]) {
                                    wl_range[0] = minWL
                                }
                                if (maxWL <= wl_range[1]) {
                                    wl_range[1] = maxWL
                                }

                                if (minWL === maxWL) {
                                    minWL = old_minWL + 0
                                    maxWL = old_maxWL + 0
                                    wl_range = old_wl_range.slice()
                                    return (alert("The spectra you have uploaded do not have overlapping wavelength ranges, so the analysis cannot be carried out."))
                                } else {
                                    batches[id] = {}

                                    slider_wl.removeAttribute('disabled');

                                    slider_wl.noUiSlider.updateOptions({
                                        range: {
                                            'min': minWL,
                                            'max': maxWL
                                        },
                                        tooltips: true,

                                    })
                                    setTimeout(console.log("rest"),1)
                                    batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors = mainProcess(batch, wl_arr, ticks, id, cd_arr, f_arr, numFiles, sFactors)

                                    Object.keys(batches).forEach(function (key, index) {


                                        document.getElementById("" + key + "-div").setAttribute("style", "background-color: transparent")

                                    });

                                    document.getElementById("" + id + "-div").setAttribute("style", "background-color:#dbdbdb ")

                                    document.getElementById("plotly-divRaw").setAttribute('style', "display:visible")
                                    document.getElementById("plotly-divHmTrend").setAttribute('style', "display:visible")
                                    document.getElementById("batchFileList").setAttribute('style', "overflow-y:scroll; height:280px; width:100%; display:visible")
                                    document.getElementById("batchFileListTitle").setAttribute('style', "display:visible")
                                    document.getElementById("summary").setAttribute('style', "display:visible;border-left: 1px solid #c8caca;")

                                }

                            }
                        }

                    };
                })(f);

                r.readAsText(f);

            }




        } else {
            alert("Failed to load files");
        }
        clearFileInput(document.getElementById('fileinput'));
        document.getElementById("loadingImg").hidden = true;
    }, 10);
}





var slider_wl = document.getElementById('wl-slider');

noUiSlider.create(slider_wl, {
    start: [0, 1],
    connect: true,
    behaviour: 'drag',
    range: {
        'min': [0],

        'max': [1]
    },
    step: 1,


    tooltips: true,

});

slider_wl.setAttribute('disabled', true)

slider_wl.noUiSlider.on('end', function () {
    wl_range = slider_wl.noUiSlider.get()
    layout.yaxis.autorange = true
    layout.xaxis.range = wl_range

    sumPNPC = []
    sFactors = getScaling(batches)

    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

        stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
        diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
        positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);


        batches[key].noisePC = positiveNumbersPC;


        batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
        if (inactive.includes(key) == false) {

            sumPNPC.push(positiveNumbersPC)
            data[key] = {

                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {

                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },

                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });

    if (sumPNPC.length > 0) {
        noiseWeighting = 1 - (math.mean(sumPNPC))
    } else {
        noiseWeighting = 1
    }

    data_l = [];
    data_l2 = [];
    if (bkey != 0) {
        document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
        document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
        document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
        document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
    }


    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });

    if (batches[bkey] != undefined) {
        wl_shapes = [
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: math.min(batches[bkey].wl),
                y0: 0,
                x1: wl_range[0],
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            },
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: wl_range[1],
                y0: 0,
                x1: math.max(batches[bkey].wl),
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            }
        ];

        layoutPre.shapes = wl_shapes
    }

    data_hm = CIOverlap(batches)

    x1 = data_l2[0].x.indexOf(math.round(wl_range[0]))
    x2 = data_l2[0].x.indexOf(math.round(wl_range[1]))

    maxy = 0;
    for (ii = 0; ii < data_l2.length; ii++) {
        if (data_l2[ii].y.slice(x2, x1 + 1).length > 0) {
            maxy_tmp = math.max(data_l2[ii].y.slice(x2, x1 + 1))

            if (maxy_tmp > maxy) {

                maxy = maxy_tmp + 0

            }
        }
        if (data_l2[ii].y.slice(x2 + data_l2[0].x.length, x1 + data_l2[0].x.length + 1).length > 0) {
            maxy_tmp = math.max(data_l2[ii].y.slice(x2 + data_l2[0].x.length, x1 + data_l2[0].x.length + 1))

            if (maxy_tmp > maxy) {

                maxy = maxy_tmp + 0

            }
        }

    }

    newUpdate1 = {
        'xaxis.range': wl_range,
        'yaxis.range': [0, maxy * 1.1],
    }
    newUpdate2 = {
        'xaxis.range': wl_range,

    }


    Plotly.relayout('plotly-div2', newUpdate1, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
    Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    if (batches[bkey] != undefined) {
        drawBufferPlot(bkey)
    }



})

slider_wl.noUiSlider.on('slide', function () {
    wl_range = slider_wl.noUiSlider.get()

    sumPNPC = []

    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]

        stdevNoise = Array(batches[key].noise.length).fill(math.median(batches[key].noise) + math.std(batches[key].noise))
        diffNoise = math.subtract(batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip), 5)
        positiveNumbersPC = diffNoise.filter(v => v > 0).length / (batches[key].noise.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip).length);


        batches[key].noisePC = positiveNumbersPC;


        batches[key].dataPC = ((areaUnderCurve(batches[key].false.mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip))) / areaUnderCurve(batches[key].false.mean)) * 100
        if (inactive.includes(key) == false) {

            sumPNPC.push(positiveNumbersPC)
            data[key] = {

                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {

                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });

    if (sumPNPC.length > 0) {
        noiseWeighting = 1 - (math.mean(sumPNPC))
    } else {
        noiseWeighting = 1
    }

    data_l = [];
    data_l2 = [];
    if (bkey != 0) {
        document.getElementById("noise-pc").innerHTML = String((batches[bkey].noisePC * 100).toFixed(1)) + "%"
        document.getElementById("noiseBall").setAttribute('style', "background-color:" + colorBall[parseInt(batches[bkey].noisePC * 100)])
        document.getElementById("data-pc").innerHTML = String((batches[bkey].dataPC).toFixed(1)) + "%"
        document.getElementById("dataBall").setAttribute('style', "background-color:" + colorBall[100 - parseInt(batches[bkey].dataPC)])
    }


    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });

    if (batches[bkey] != undefined) {
        wl_shapes = [
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: math.min(batches[bkey].wl),
                y0: 0,
                x1: wl_range[0],
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            },
            {
                type: "rect",
                xref: 'x',
                yref: 'paper',
                x0: wl_range[1],
                y0: 0,
                x1: math.max(batches[bkey].wl),
                y1: 1,
                fillcolor: "#8a8c8e",
                opacity: 0.3,
                line: {
                    width: 0
                }
            }
        ];

        layoutPre.shapes = wl_shapes

        Plotly.react('plotly-divRaw', data_preview, layoutPre, { modeBarButtons: raw_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
        drawBufferPlot(bkey)
    }

})

var slider_alpha = document.getElementById('alpha-slider');

noUiSlider.create(slider_alpha, {
    start: (1 - alpha) * 100,

    behaviour: 'drag',
    range: {
        'min': [80.0],
        '20%': [85.0],
        '40%': [90.0],
        '60%': [95.0],
        '80%': [99.0],
        'max': [99.9]
    },
    step: 0.1,
    pips: {
        mode: 'range',
        density: 10,
        format: wNumb({
            decimals: 1,

        }),
        stepped: true

    },
    tooltips: wNumb({ decimals: 1, suffix: "%" }),
});

slider_alpha.noUiSlider.on('set', function () {

    alpha = 1 - (slider_alpha.noUiSlider.get()) / 100
    sFactors = getScaling(batches)
    Object.keys(batches).forEach(function (key, index) {

        wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
        let cd_arr_t = batches[key]["true"]["tcdarr"]

        confInt = []

        for (k = 0; k < cd_arr_t.length; k++) {

            confInt.push(jStat.tci(0, alpha, cd_arr_t[k])[1])

        }


        batches[key]["true"].confInt = confInt
        if (inactive.includes(key) == false) {
            data[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
            };
            data2[key] = {
                x: batches[key].wl.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                y: batches[key]["true"].mean.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                error_y: {
                    type: 'data',
                    array: batches[key]["true"].confInt.slice(wl_slice[0], wl_slice[1]).wlskip(batches[key].wl.slice(wl_slice[0], wl_slice[1]), cur_wlskip),
                    visible: true
                },
                line:{
                    color:colScheme[(key) % colScheme.length],
                },
                mode: "lines",
                name: "B" + batches[key].name+": "+batches[key].userName,
                type: "scatter",
                hoverinfo: "name+x",

            };
        }
    });
    data_l = [];
    data_l2 = [];

    Object.keys(data).forEach(function (key, index) {



        data_l.push(data[key])
        data_l2.push(data2[key])

    });
    data_hm = CIOverlap(batches)
    Plotly.react('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    Plotly.react('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
    layoutOL.xaxis.range = myPlot2.layout.xaxis.range




});

function rmsdPW(batches) {
    x = []
    y = []
    z = []
    deviations = []

    function rmsd(arr1, arr2) {
        diff = math.subtract(arr1, arr2)
        diff_2 = math.square(diff)
        diff_2_m = math.mean(diff_2)
        diff_2_m_rt = math.sqrt(diff_2_m)

        return ([diff_2_m_rt, math.abs(diff)])
    }

    batches_l = []
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {
            batches_l.push(batches[key])
            x.push("B" + String(batches[key].name))
            y.push("B" + String(batches[key].name))
        }
    });

    z_sig = []

    for (j = 0; j < batches_l.length; j++) {

        m1 = batches_l[j]["true"].mean.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]).wlskip(batches_l[j].wl.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]), cur_wlskip)


        z2 = []
        z_sig2 = []
        for (k = 0; k < batches_l.length; k++) {


            m2 = batches_l[k]["true"].mean.slice(batches_l[k].wlSlice[0], batches_l[k].wlSlice[1]).wlskip(batches_l[k].wl.slice(batches_l[k].wlSlice[0], batches_l[k].wlSlice[1]), cur_wlskip)
            rmsd_stuff = rmsd(m1, m2)
            if (j != k) {
                deviations.push(rmsd_stuff[1])
            }

            sig_dev = []

            for (qq = 0; qq < non_overlaps.length; qq++) {
                if (non_overlaps[qq] != 0) {
                    if (rmsd_stuff[1][qq] >= dev_t) {
                        sig_dev.push(dev_t)
                    } else {
                        sig_dev.push(rmsd_stuff[1][qq])
                    }
                }
            }


            z2.push(rmsd_stuff[0])
            if (sig_dev.length > 0) {
                z_sig2.push((math.sqrt(math.pow(math.mean(sig_dev), 2))))
            } else {
                z_sig2.push(0)
            }
        }
        z.push(z2)
        z_sig.push(z_sig2)
    }

    av_deviations = math.mean(deviations, 0)

    devwl = batches_l[0].wl.slice(batches_l[0].wlSlice[0], batches_l[0].wlSlice[1]).wlskip(batches_l[0].wl, cur_wlskip)

    averageRMSD = (math.sum(z) / ((batches_l.length) ** 2 - (batches_l.length))).toFixed(2)

    data_dev = [{
        type: 'scatter',
        fill: 'tozeroy',
        x: devwl,
        y: av_deviations,
        hoverinfo: 'skip',
        line: { color: mode[metric].color }

    }]

    sig_wl = []
    sig_dev = []
    sig_text = []

    for (i = 0; i < non_overlaps.length; i++) {
        if (non_overlaps[i] != 0) {
            sig_wl.push(devwl[i])
            if (av_deviations[i] >= dev_t) {
                sig_dev.push(dev_t)
                sig_text.push(av_deviations[i])
            } else {
                sig_dev.push(av_deviations[i])
                sig_text.push(av_deviations[i])
            }


        }
    }


    data_dev.push({
        type: 'scatter',

        x: sig_wl,
        y: sig_dev,
        text: sig_text,
        mode: "markers",
        hovertemplate: '%{x}' + 'nm: ' + ' %{text:.3f}',
        marker: { color: "blue", symbol: "cross", size: 5 }


    })

    data_dev.push({
        type: 'scatter',

        x: devwl,
        y: new Array(devwl.length).fill(averageRMSD),

        hovertemplate: 'Average RMSD: ' + '%{y}',
        line: { color: "blue" },


    })

    layoutDEV.yaxis.range = [0, dev_t]
    layoutDEV.xaxis.range = layout.xaxis.range




    data_hm2 = [
        {
            z: z,
            x: x,
            y: y,
            type: 'heatmap',
            colorscale: [


                ['0.0', 'rgb(19, 214, 45)'],
                ['0.25', 'rgb(240, 247, 43)'],
                ['0.5', 'rgb(247, 233, 44)'],
                ['0.75', 'rgb(247, 103, 37)'],
                ['1.0', 'rgb(247, 43, 43)']
            ],//mode["RMSD"].colorScale,
            zmin: 0,
            zmax: dev_t
        }
    ];


    return ([av_deviations, z_sig])


}

function rmsdPW2(batches) {
    x = []
    y = []
    z = []
    deviations = []

    function rmsd(arr1, arr2) {
        diff = math.subtract(arr1, arr2)
        diff_2 = math.square(diff)
        diff_2_m = math.mean(diff_2)
        diff_2_m_rt = math.sqrt(diff_2_m)

        return ([diff_2_m_rt, math.abs(diff)])
    }

    batches_l = []
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {
            batches_l.push(batches[key])
            x.push("B" + String(batches[key].name))
            y.push("B" + String(batches[key].name))
        }
    });

    z_sig = []

    for (j = 0; j < batches_l.length; j++) {

        m1 = batches_l[j]["true"].mean.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]).wlskip(batches_l[j].wl.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]), cur_wlskip)


        z2 = []
        z_sig2 = []
        for (k = 0; k < batches_l.length; k++) {


            m2 = batches_l[k]["true"].mean.slice(batches_l[k].wlSlice[0], batches_l[k].wlSlice[1]).wlskip(batches_l[k].wl.slice(batches_l[k].wlSlice[0], batches_l[k].wlSlice[1]), cur_wlskip)
            rmsd_stuff = rmsd(m1, m2)
            if (j != k) {
                deviations.push(rmsd_stuff[1])
            }

            sig_dev = []

            for (qq = 0; qq < non_overlaps.length; qq++) {
                if (non_overlaps[qq] != 0) {
                    if (rmsd_stuff[1][qq] >= dev_t) {
                        sig_dev.push(dev_t)
                    } else {
                        sig_dev.push(rmsd_stuff[1][qq])
                    }
                }
            }


            z2.push(rmsd_stuff[0])
            if (sig_dev.length > 0) {
                z_sig2.push((math.sqrt(math.pow(math.mean(sig_dev), 2))))
            } else {
                z_sig2.push(0)
            }
        }
        z.push(z2)
        z_sig.push(z_sig2)
    }

    av_deviations = math.mean(deviations, 0)

    devwl = batches_l[0].wl.slice(batches_l[0].wlSlice[0], batches_l[0].wlSlice[1]).wlskip(batches_l[0].wl, cur_wlskip)

    averageRMSD = (math.sum(z) / ((batches_l.length) ** 2 - (batches_l.length))).toFixed(2)



    sig_wl = []
    sig_dev = []
    sig_text = []

    for (i = 0; i < non_overlaps.length; i++) {
        if (non_overlaps[i] != 0) {
            sig_wl.push(devwl[i])
            if (av_deviations[i] >= dev_t) {
                sig_dev.push(dev_t)
                sig_text.push(av_deviations[i])
            } else {
                sig_dev.push(av_deviations[i])
                sig_text.push(av_deviations[i])
            }


        }
    }

    return ([av_deviations, z_sig])


}




function twoSampleTtest() {
    x = []
    y = []
    z = []

    batches_l = []
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {
            batches_l.push(batches[key])
            x.push("B" + String(batches[key].name))
            y.push("B" + String(batches[key].name))
        }
    });





    for (j = 0; j < batches_l.length; j++) {
        s1 = batches_l[j]["true"].area

        n1 = s1.length
        m1 = math.mean(s1)
        v1 = math.var(s1)

        z2 = []
        for (k = 0; k < batches_l.length; k++) {
            not_significant = 0



            s2 = batches_l[k]["true"].area

            n2 = s2.length
            m2 = math.mean(s2)
            v2 = math.var(s2)
            dof = n1 + n2 - 2

            t = (m1 - m2) / math.sqrt((v1 ** 2 / n1) + (v2 ** 2 / n2))

            tcrit = jStat.studentt.inv(alpha, dof)

            z2.push(math.abs(tcrit) - math.abs(t))
        }
        z.push(z2)
    }
    data_hm_new = [
        {
            z: z,
            x: x,
            y: y,
            type: 'heatmap',
            colorscale: [


                ['0.0', 'rgb(19, 214, 45)'],
                ['0.15', 'rgb(240, 247, 43)'],
                ['0.4', 'rgb(247, 233, 44)'],
                ['0.6', 'rgb(247, 103, 37)'],
                ['1.0', 'rgb(247, 43, 43)']
            ],
            /* zmin:0,
            zmax:1 */
        }
    ];
    return (z)

}


var non_overlaps;

var score = 0;

var metric = "confInt"
var mode = {
    'confInt': {},
    'stderr': {},
    'RMSD': {}
}

mode['confInt'].color = "rgb(247, 43, 43)"
mode['confInt'].colorScale = [
    ['0.0', 'rgb(19, 214, 45)'],
    ['0.15', 'rgb(240, 247, 43)'],
    ['0.4', 'rgb(247, 233, 44)'],
    ['0.6', 'rgb(247, 103, 37)'],
    ['1.0', 'rgb(247, 43, 43)']
]
mode['RMSD'].colorScale = [
    ['0.0', 'rgb(19, 214, 45)'],
    ['0.25', 'rgb(240, 247, 43)'],
    ['0.5', 'rgb(247, 233, 44)'],
    ['0.75', 'rgb(247, 103, 37)'],
    ['1.0', 'rgb(247, 43, 43)']
]
mode['stderr'].color = "rgb(19, 214, 45)"
mode['stderr'].colorScale = [
    ['0.0', 'rgb(247, 43, 43)'],
    ['0.15', 'rgb(247, 103, 37)'],
    ['0.4', 'rgb(247, 233, 44)'],
    ['0.6', 'rgb(240, 247, 43)'],
    ['1.0', 'rgb(19, 214, 45)']
]

function diffCI(mean1, mean2, std1, std2, n1, n2, alpha) {
    CI = [0, 0]

    diffmeans = math.abs(math.subtract(mean1, mean2))
    stddenom = n1 + n2 - 2
    t99 = jStat.studentt.inv(1 - alpha, stddenom)
    stdnumer = std1 ** 2 / n1.length + std2 ** 2 / n2.length
    stdnumer = math.add(math.divide(math.dotPow(std1, 2), n1), math.divide(math.dotPow(std2, 2), n2))

    rootStdSum = math.dotPow(math.divide(stdnumer, stddenom), 0.5)

    Troot = math.multiply(rootStdSum, t99)
    CI[0] = diffmeans
    CI[1] = Troot

    return (CI)
}




function convertHex(hex, opacity) {
    hex = hex.replace('#', '');
    r = parseInt(hex.substring(0, 2), 16);
    g = parseInt(hex.substring(2, 4), 16);
    b = parseInt(hex.substring(4, 6), 16);

    result = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
    return result;
}



function drawDiffPlot(all_confs, all_differences, all_overlaps, wls, batches_l, focus) {

    if (batches_l.length == 1) {
        data_l2 = []
        data_l2.push({
            x: [],
            y: [],


            mode: "lines",
            name: "Premium",
            type: "scatter",
            hoverinfo: "name+x",


        });

        plot2 = Plotly.react('plotly-div2', data_l2, layout2, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
    } else {
        data_l2 = []
        present = []
        l = focus
        l4 = 0
        Object.keys(batches).forEach(function (key, index) {
            l4++
            if (batches[key].name == batches_l[l].name) {
                focusCol = l4 + 0
            }
        })



        l3 = -1
        l2 = -1
        maxy = 0
        let allDiffsFromZero = []
        Object.keys(batches).forEach(function (key, index) {
            l3++
            if (inactive.includes(key) == false) {
                l2++
                if (l != l2) {
                    na1 = batches_l[l].name
                    na2 = batches_l[l2].name
                    alt_name1 = "" + na1 + "_" + na2
                    alt_name2 = "" + na2 + "_" + na1
                    if (!present.includes(alt_name1) || !present.includes(alt_name2)) {
                        present.push(alt_name1)
                        present.push(alt_name2)


                        diffsFromZero = []
                        lowerBounds = math.subtract(all_differences[parseInt(na1)][parseInt(na2)], all_confs[parseInt(na1)][parseInt(na2)])
                        for (fff = 0; fff < lowerBounds.length; fff++) {
                            if (lowerBounds[fff] > 0) {
                                diffsFromZero.push(lowerBounds[fff])
                                if (lowerBounds[fff] > maxy) {
                                    maxy = lowerBounds[fff]
                                }
                            } else {
                                diffsFromZero.push(-0.01)
                            }
                        }

                        allDiffsFromZero.push(diffsFromZero)
                    }
                }
            }
        });

        data_l2 = [{
            x: wls,
            y: math.mean(allDiffsFromZero, 0),
            type: "bar",
            marker: {
                color: colScheme[focus + 1],
            }
        }]


        layout2 = {
            paper_bgcolor: "rgb(255,255,255)",
            plot_bgcolor: "rgb(255,255,255)",
            autosize: false,
            width: 600,
            height: 130,
            margin: {
                t: 0,
                b: 50,
                r: 30,
                l: 50
            },
            hovermode: 'closest',
            showlegend: false,
            dragmode: 'pan',
            xaxis: {
                range: myPlot.layout.xaxis.range,
                gridcolor: "rgb(229,229,229)",

                showgrid: true,
                showline: true,
                mirror: true,
                showticklabels: true,
                tickcolor: "rgb(127,127,127)",
                ticks: "outside",
                zeroline: true,
                fixedrange: true
            },
            yaxis: {
                range: [0, maxDiff],
                rangemode: "nonnegative",
                gridcolor: "rgb(229,229,229)",
                showgrid: true,
                showline: true,
                mirror: true,
                showticklabels: false,
                tickcolor: "rgb(127,127,127)",
                ticks: "outside",
                zeroline: true,
                fixedrange: true
            }

        };



        plot2 = Plotly.react('plotly-div2', data_l2, layout2, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });

        data_overlap = [{
            type: 'scatter',
            fill: 'tozeroy',
            x: olwl,
            y: all_overlaps[focus],
            hoverinfo: 'x+y',
            line: { color: mode[metric].color }

        }]

        layoutOL.yaxis.range = [0, batches_l.length - 1]
        layoutOL.xaxis.range = myPlot2.layout.xaxis.range


    }
}

var all_confs = {};
var all_differences = {};
var all_overlaps = {};
var conf;
var z_score;
var pw_zscore;
var maxDiff;



var refSet = []
var refSetInd = []


function refSetMod() {
    refSet = []
    refSetInd = []
    i = 0
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {
            if (document.getElementById("refchk-" + batches[key].name).checked) {
                refSet.push(batches[key].name)
                refSetInd.push(i)
            }
            i++
        }
    });
    CIOverlap(batches)
}

function refSetModSimple() {
    refSet = []
    refSetInd = []
    i = 0
    Object.keys(batches).forEach(function (key, index) {
        if (inactive.includes(key) == false) {
            if (document.getElementById("refchkS-" + batches[key].name).checked) {
                refSet.push(batches[key].name)
                refSetInd.push(i)
            }
            i++
        }
    });
    CIOverlap(batches)
}


var qcmode = false
document.getElementById("qcmode-1").checked = false

document.getElementById("qcmode-1").addEventListener("click", function (e) {
    qcmode = e.target.checked
    
    CIOverlap(batches)
})


function SNR(m, s, n) {

    if (math.mean(s) < 0) {

    }
    sigNratio = math.abs(math.mean(s) / math.sqrt(n))
    return (sigNratio)
}
var critVal = 0.95

var equivMult = 2;


function pooledVariance(d1,d2){
    let s1=math.std(d1)
    let s2=math.std(d2)
    let n1=d1.length
    let n2=d2.length
    let sp=math.sqrt(((n1-1)*s1**2+(n2-1)*s2**2)/(n1+n2-2))
    return(sp)
}

var list_equivMult;

var slider_equiv = document.getElementById('equiv-slider');

noUiSlider.create(slider_equiv, {
    start: 1.5,

    behaviour: 'drag',
    range: {
        'min': [1.5],
        
        'max': [3.0]
    },
    step: 0.001,
    
    tooltips: wNumb({ decimals: 2, suffix: "<sub>ref</sub>" }),
});

var slider_equiv_det = document.getElementById('equiv_det-slider');

noUiSlider.create(slider_equiv_det, {
    start: 1.5,

    behaviour: 'drag',
    range: {
        'min': [1.5],
        
        'max': [3.0]
    },
    step: 0.001,
    
    tooltips: wNumb({ decimals: 2, suffix: "<sub>ref</sub>" }),
});



var equivSlide;

slider_equiv.noUiSlider.on('end', function () {
    
    if(qcmode){
        equivSlide = slider_equiv.noUiSlider.get();
        slider_equiv_det.noUiSlider.set(equivSlide);
        console.log(equivSlide)
    }else{
        equivSlide = slider_equiv.noUiSlider.get();
        slider_equiv_det.noUiSlider.set(equivSlide);
        console.log(equivSlide)
        CIOverlap(batches)
    }
    
});

slider_equiv_det.noUiSlider.on('end', function () {
    
    if(qcmode){
        equivSlide = slider_equiv_det.noUiSlider.get();
        slider_equiv.noUiSlider.set(equivSlide);
        console.log(equivSlide)
    }else{
        equivSlide = slider_equiv_det.noUiSlider.get();
        slider_equiv.noUiSlider.set(equivSlide);
        console.log(equivSlide)
        CIOverlap(batches)
    }
    
});


var min_snr
var max_snr
var snr_diff
var normal_curvex
var normal_curvey

function CIOverlap(batches = batches, final = true) {

    console.log("cioverlap run" + final)
    console.trace()

    if(qcmode){
        slider_equiv.setAttribute('disabled', true)
        slider_equiv_det.setAttribute('disabled', true)
    }else{
        slider_equiv.removeAttribute('disabled')
        slider_equiv_det.removeAttribute('disabled')
    }

    val68 = 0
    val95 = 0
    val95_text = "XXXX"
    val68_text = "XXXX"

    document.getElementById("refSetOptions").innerHTML = ""
    document.getElementById("refSetOptionsSimp").innerHTML = ""
    document.getElementById("refSetFacts").innerHTML = ""
    batches_l = []

    refSetActive = []
    refSetInd = []
    refSetInd_counter = 0
    refSetIndAll = []


    Object.keys(batches).forEach(function (key, index) {
        if (refSet.includes(key)) {
            refSetIndAll.push(index)
        }
        if (inactive.includes(key) == false) {
            wl_slice = [batches[key].wl.indexOf(parseFloat(wl_range[1])), batches[key].wl.indexOf(parseFloat(wl_range[0])) + 1]
            batches[key]["wlSlice"] = wl_slice
            batches_l.push(batches[key])

            if (qcmode) {
                if (refSet.includes(key)) {
                    refSetActive.push(key)
                    refSetInd.push(refSetInd_counter)

                }
            } else {
                refSetActive.push(key)
                refSetInd.push(refSetInd_counter)
            }
            refSetInd_counter++;

        }
    });

    all_confs = {};
    all_differences = {};
    all_overlaps = [];

    maxDiff = 0

    if (batches_l.length > 2) {

        x = []
        y = []
        z = []
        z_dev = [] // for heatmap
        zdev2 = [] // for score

        refsetTable = document.createElement("table")
        refsetTable.className = "table table-sm table-hover"
        refsetTable.setAttribute("style", "width:100%;")
        refsetTHead = document.createElement("thead")
        refsetTHead.className = "thead-light"
        if (qcmode) {
            refsetTHead.innerHTML = ""
            refsetTHead.innerHTML += "<tr><th class='notPrinted'  style='width:80px'>Diff.<br>Spectra</th><th style='text-align:right'></th><th style='text-align:right'>Within Batch Av. SE. ()</th><th style='text-align:right'>Av. Spectral Diff. ()</th><th style='text-align:right'>SAME?</th><th  class='notPrinted' style='width:150px; text-align:center'>Ref Set?</th></tr>"
        } else {
            refsetTHead.innerHTML = ""
            refsetTHead.innerHTML += "<tr><th class='notPrinted' style='width:80px'>Diff.<br>Spectra</th><th style='text-align:right'></th><th style='text-align:right'>Within Batch Av. SE. ()</th><th style='text-align:right'>Av. Spectral Diff. ()</th><th style='text-align:right'>SAME?</th><th  class='notPrinted' style='width:150px; text-align:center'></th></tr>"
        }

        refsetTable.appendChild(refsetTHead)
        refsetTBody = document.createElement("tbody")

        refsetTHead.setAttribute("style", "position:sticky;top:0;font-size:small;background:white")



        simple_refsetTable = document.createElement("table")
        simple_refsetTable.className = "table table-sm table-hover"
        simple_refsetTable.setAttribute("style", "width:100%;font-size:large")
        simple_refsetTHead = document.createElement("thead")
        simple_refsetTHead.className = "thead-light"
        if (qcmode) {
            simple_refsetTHead.innerHTML = ""
            simple_refsetTHead.innerHTML += "<tr><th style='text-align:left'>Batch Name</th><th style='text-align:right'>SAME?</th><th  class='notPrinted' style='width:150px; text-align:center'>Ref Set?</th></tr>"
        } else {
            simple_refsetTHead.innerHTML = ""
            simple_refsetTHead.innerHTML += "<tr><th style='text-align:left'>Batch Name</th><th style='text-align:right'>SAME?</th><th  class='notPrinted' style='width:150px; text-align:center'></th></tr>"
        }

        simple_refsetTable.appendChild(simple_refsetTHead)
        simple_refsetTBody = document.createElement("tbody")

        simple_refsetTHead.setAttribute("style", "position:sticky;top:0;font-size:large;background:white")

        for (i = 0; i < batches_l.length; i++) {

            non_overlaps = Array(batches_l[0].wl.length).fill(0).wlskip(batches_l[0].wl, cur_wlskip)

            if (document.getElementById("dBaView-" + batches_l[i].name)) {
                if (document.getElementById("dBaView-" + batches_l[i].name).checked) {
                    focus = i + 0
                }
            } else {
                if (focus != undefined && focus < batches_l.length) {
                    focus = focus
                } else {
                    focus = batches_l.length - 1
                }

            }
            var all_confsIn = {};
            var all_differencesIn = {};

            name1 = batches_l[i].name
            m1 = batches_l[i]["true"].mean.slice(batches_l[i].wlSlice[0], batches_l[i].wlSlice[1]).wlskip(batches_l[i].wl.slice(batches_l[i].wlSlice[0], batches_l[i].wlSlice[1]), cur_wlskip)


            c1 = batches_l[i]["true"].std.slice(batches_l[i].wlSlice[0], batches_l[i].wlSlice[1]).wlskip(batches_l[i].wl.slice(batches_l[i].wlSlice[0], batches_l[i].wlSlice[1]), cur_wlskip)

            x.push("B" + name1)
            y.push("B" + name1)
            z2 = []

            z_dev2 = []
            z_dev3 = []
            for (j = 0; j < batches_l.length; j++) {

                m2 = batches_l[j]["true"].mean.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]).wlskip(batches_l[j].wl.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]), cur_wlskip)
                c2 = batches_l[j]["true"].std.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]).wlskip(batches_l[j].wl.slice(batches_l[j].wlSlice[0], batches_l[j].wlSlice[1]), cur_wlskip)

                overlap = 0;

                conf = diffCI(m1, m2, c1, c2, c1.length, c2.length, 1 - alpha)


                z_dev2b = []
                for (k = 0; k < conf[0].length; k++) {
                    if (conf[0][k] - conf[1][k] <= 0) {
                        overlap += 1
                        z_dev2b.push(0)
                    } else {
                        non_overlaps[k] += 1

                        z_dev2b.push(conf[0][k]) //putting distance in if its significant


                    }

                }

                all_confsIn[batches_l[j].name] = conf[1]
                all_differencesIn[batches_l[j].name] = conf[0]
                all_overlaps[i] = non_overlaps

                if (maxDiff < math.max(conf[0])) {
                    maxDiff = math.max(conf[0])
                }

                if (metric == "confInt") {
                    z2.push(1 - (overlap / m2.length))
                } else if (metric = "stderr") {

                    z2.push((overlap / m2.length))
                }

                z_dev2.push(z_dev2b)
                if (z_dev2b.length > 0) {
                    z_dev3.push(math.mean(z_dev2b))
                } else {
                    z_dev3.push(0)
                }

            }
            all_confs[batches_l[i].name] = all_confsIn
            all_differences[batches_l[i].name] = all_differencesIn

            z.push(z2)
            z_dev.push(z_dev3)
            zdev2.push(z_dev2)

        }

        z_overlap = z.slice()

        olwl = batches_l[0].wl.slice(batches_l[0].wlSlice[0], batches_l[0].wlSlice[1]).wlskip(batches_l[0].wl, cur_wlskip)
        olwl = olwl.filter(function (element) {
            return element !== undefined;
        });

        drawDiffPlot(all_confs, all_differences, all_overlaps, olwl, batches_l, focus)


        zdev2b = []

        pw_zscore = []



        z_dev_thres = []
        for (ii = 0; ii < z_dev.length; ii++) {
            z_dev_thres2 = []
            for (jj = 0; jj < z_dev.length; jj++) {
                if (z_dev[ii][jj] > dev_t) {
                    z_dev_thres2.push(dev_t)
                } else {
                    z_dev_thres2.push(z_dev[ii][jj])
                }
            }
            z_dev_thres.push(z_dev_thres2)
        }

        z_score = math.sum(math.divide(z_dev_thres, dev_t)) / (batches_l.length ** 2 - batches_l.length)


        pw_zscore = z_dev
        data_hm = [
            {
                z: pw_zscore.slice().reverse(),
                x: x,
                y: y.reverse(),
                type: 'heatmap',
                colorscale: [

                    ['0.0', colorBall[0]],

                    ['0.5', colorBall[25]],

                    ['1.0', colorBall[100]],
                ],
                zmin: 0,

            }
        ];

        Plotly.react('plotly-divHm', data_hm, layoutHM, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })


        pw_av_zscore = []



        flat_pw_zscore = []
        flat_pw_rmsd = []
        pw_av_rmsd = []
        flat_pw_ol = []
        pw_av_ol = []

        for (ii = 0; ii < pw_zscore.length; ii++) {
            pw_av_zscore_tmp = []
            pw_av_rmsd_tmp = []
            pw_av_ol_tmp = []
            for (jj = 0; jj < pw_zscore[ii].length; jj++) {
                if (jj != ii && refSetActive.includes(batches_l[jj].name) == true) {

                    pw_av_zscore_tmp.push(pw_zscore[ii][jj])
                    pw_av_rmsd_tmp.push(z_dev[ii][jj])
                    pw_av_ol_tmp.push(z_overlap[ii][jj])

                }
                if (jj != ii && jj > ii && refSetActive.includes(batches_l[ii].name) == true && refSetActive.includes(batches_l[jj].name) == true) {
                    flat_pw_zscore.push(pw_zscore[ii][jj])
                    flat_pw_rmsd.push(z_dev[ii][jj])
                    flat_pw_ol.push(z_overlap[ii][jj])
                }

            }
            if (pw_av_zscore_tmp.length > 0) {
                pw_av_zscore.push(math.mean(pw_av_zscore_tmp))
                pw_av_rmsd.push(math.mean(pw_av_rmsd_tmp))
                pw_av_ol.push(math.mean(pw_av_ol_tmp))
            }

        }

        if (flat_pw_zscore.length > 0) {
            pw_zscore_std = math.std(flat_pw_zscore)
            pw_zscore_mean = math.mean(flat_pw_zscore)
        }
        i = 0
        index2 = -1

        all_zscores = []


        all_snr = []
        refSetsnr = []
        testSetsnr = []

        Object.keys(batches).forEach(function (key, index) {
            if (inactive.includes(key) == false) {
                m1 = batches[key]["true"].mean.slice(batches[key].wlSlice[0], batches[key].wlSlice[1]).wlskip(batches[key].wl.slice(batches[key].wlSlice[0], batches[key].wlSlice[1]), cur_wlskip)
                c1 = batches[key]["true"].std.slice(batches[key].wlSlice[0], batches[key].wlSlice[1]).wlskip(batches[key].wl.slice(batches[key].wlSlice[0], batches[key].wlSlice[1]), cur_wlskip)
                tmp_snr = SNR(m1, c1, batches[key].fileList.length)
                if (qcmode) {
                    if (refSetActive.includes(batches[key].name)) {
                        refSetsnr.push(tmp_snr)
                    } else {
                        testSetsnr.push(tmp_snr)
                    }
                }
                all_snr.push(tmp_snr)
            }
        })





        if (pw_av_zscore.length > 0) {
            min_zscore = math.min(pw_av_zscore)
            z_score_pow = 0 - Math.round(1 / min_zscore).toFixed(0).length
            pw_av_zscore_text = []
            zscore_pow_text = " x 10<sup>" + z_score_pow + "</sup>"
            for (let j = 0; j < pw_av_zscore.length; j++) {
                pw_av_zscore_text.push((pw_av_zscore[j] / 10 ** z_score_pow).toFixed(2) + zscore_pow_text)
            }
        }
        if (all_snr.length > 0) {
            min_snr = math.min(all_snr)
            snr_pow = 0 - Math.round(1 / min_snr).toFixed(0).length
            all_snr_text = []
            snr_pow_text = " x 10<sup>" + snr_pow + "</sup>"
            for (let j = 0; j < all_snr.length; j++) {
                all_snr_text.push((all_snr[j] / 10 ** snr_pow).toFixed(2) + snr_pow_text)
            }
        }


        allScoreCI = []
        allFails = []
        allDQFails = []

        passFlagFail = []

        printTable=[]

        // do equivMulti stuff here - do LOO for ref set only

        EQrefScore = []
        EQrefNames = []
        EQvsScore = []
        EQvsScore_all = []
        EQrefScore_all = []
        EQvsNames = []
        EQvsNamesLong= []

        for (ppp = 0; ppp < pw_zscore.length; ppp++) {
            if(refSetInd.includes(ppp)){
                EQvsScore_all_tmp = []
                EQrefScore_all_tmp = []
                for (qqq = 0; qqq < pw_zscore[ppp].length; qqq++) {
                    if(refSetInd.includes(qqq)){
                        
                        if (qqq != ppp) {
                            if (pw_zscore[ppp][qqq] != 0) {
                                if (EQvsScore.includes(pw_zscore[ppp][qqq]) == false) {
                                    EQvsScore.push((pw_zscore[ppp][qqq]))
                                }

                                EQvsScore_all_tmp.push((pw_zscore[ppp][qqq]))
                            }


                        }
                    }
                }
                EQvsScore_all.push(EQvsScore_all_tmp)
                EQvsNamesLong.push(x[ppp] + ": "+batches_l[ppp].userName)
                EQvsNames.push(x[ppp])

                for (qqq = 0; qqq < pw_zscore.length; qqq++) {
                    if(refSetInd.includes(qqq)){
                        for (rrr = 0; rrr < pw_zscore[qqq].length; rrr++) {
                            if(refSetInd.includes(rrr)){
                                if (rrr != ppp && qqq != ppp && rrr < qqq) {
                                    EQrefScore_all_tmp.push(pw_zscore[qqq][rrr])
                                }
                            }
                        }
                    }


                }
                EQrefScore_all.push(EQrefScore_all_tmp)
            }
            


        }

        equivMax=false
        
        
        list_equivMult=[];
        for(let g=0;g<EQrefScore_all.length;g++){
            if(EQrefScore_all[g].length>0){
                tmp_ci = diffCI(math.mean(EQrefScore_all[g]), math.mean(EQvsScore_all[g]), math.std(EQrefScore_all[g]), math.std(EQvsScore_all[g]), EQrefScore_all[g].length, EQvsScore_all[g].length, 0.1)
                tmp_combo = math.mean(EQvsScore_all[g])+tmp_ci[1]
                
                tmp_Max=tmp_combo+0
                tmp_equivMult=((tmp_combo-math.mean(EQrefScore_all[g]))/math.std(EQrefScore_all[g]))
                

                tmp_equivMult=Math.ceil(tmp_equivMult*100)/100
                if(tmp_equivMult<1.5){
                   tmp_equivMult=1.5
                }
                if(tmp_equivMult>3.0){
                   equivMax=true
                   equivMaxVal=tmp_equivMult+0
                   tmp_equivMult=3.0
                }
                list_equivMult.push(tmp_equivMult)
            }
        }
        



        if (qcmode) {

            

            //equivMult stuff
            if(list_equivMult.length>0){
                equivMult=math.max(list_equivMult)
            }else{
                equivMult=1.5
            }
            let eMessage=document.getElementsByClassName("equiv-message")
            if(equivMax){
                eMessage[0].innerHTML="Calculated value ("+equivMaxVal.toFixed(2)+") greater than 3.0. Check your reference set for batches with high variance from the mean."
                eMessage[1].innerHTML="Calculated value ("+equivMaxVal.toFixed(2)+") greater than 3.0. Check your reference set for batches with high variance from the mean."
            }else{
                eMessage[0].innerHTML=""
                eMessage[0].innerHTML=""
            }

            slider_equiv.noUiSlider.set(equivMult)
            slider_equiv_det.noUiSlider.set(equivMult)

            refScore = []
            refNames = []
            vsScore = []
            vsScore_all = []
            refScore_all = []
            vsNames = []
            vsNamesLong= []
            vsNamesLong= []

            for (ppp = 0; ppp < pw_zscore.length; ppp++) {
                vsScore_all_tmp = []
                refScore_all_tmp = []
                for (qqq = 0; qqq < pw_zscore[ppp].length; qqq++) {
                    if (refSetInd.includes(ppp) && refSetInd.includes(qqq)) {
                        if (pw_zscore[ppp][qqq] != 0) {
                            if (refScore.includes(pw_zscore[ppp][qqq]) == false) {
                                refScore.push((pw_zscore[ppp][qqq]))
                            }

                            refScore_all_tmp.push((pw_zscore[ppp][qqq]))
                        }

                        refNames.push(x[ppp] + "_" + x[qqq])
                    } else if (refSetInd.includes(qqq)) {
                        vsScore_all_tmp.push((pw_zscore[ppp][qqq]))

                    }
                }

                vsScore_all.push(vsScore_all_tmp)
                if (refSetInd.includes(ppp) == false) {
                    vsScore.push(pw_av_zscore[ppp])
                    vsNamesLong.push(x[ppp] + ": "+batches_l[ppp].userName)
                    vsNames.push(x[ppp])
                }
                refScore_all.push(refScore_all_tmp)


            }
            if (refScore.length > 1) {
                pw_zscore_std = math.std(refScore)
                pw_zscore_mean = math.mean(refScore)
                
                

            } else {
                pw_zscore_std = 0
                pw_zscore_mean = 0
            }



            index3 = -1; // annoying counter for passFlagFail - iterates for non-refset
            Object.keys(batches).forEach(function (key, index) {
                if (inactive.includes(key) == false) {

                    simple_refsetTr = document.createElement("tr")
                    if (refSetActive.includes(batches[key].name)) {
                        printTable.push({})
                        refsetTr = document.createElement("tr")

                        refsetTD6 = document.createElement("td")
                        newRad = document.createElement("input")
                        newRad.setAttribute('type', "radio");

                        newRad.setAttribute('name', "batchView");
                        newRad.setAttribute('value', "dBaView-" + batches[key].name);
                        newRad.id = "dBaView-" + batches[key].name
                        index2++
                        if (index2 == focus) {
                            newRad.checked = true
                        } else {
                            newRad.checked = false
                        }
                        newRad.addEventListener('click', function () {
                            for (i = 0; i < batches_l.length; i++) {
                                if (document.getElementById("dBaView-" + batches_l[i].name).checked) {
                                    focus = i + 0
                                }
                            }
                            drawDiffPlot(all_confs, all_differences, all_overlaps, olwl, batches_l, focus)
                        }, false)
                        refsetTD6.appendChild(newRad)

                        refsetTD = document.createElement("td")
                        refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                        refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName



                        simple_refsetTD = document.createElement("td")
                        simple_refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                        simple_refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName

                        refsetTD5 = document.createElement("td")



                        if (refSetActive.length > 1) {
                            refsetTD5.innerHTML += all_snr_text[i]
                            tmp_score = tscoreSingle(math.mean(refSetsnr), all_snr[i], math.std(refSetsnr), refSetActive.length)
                            tmp_z = compute(tmp_score, refSetActive.length - 1)
                            tmp_z = tmp_score
                            max_t = jStat.studentt.inv(0.0001, refSetActive.length - 1)
                            t68snr = jStat.studentt.inv(1 - 0.68, refSetActive.length - 1)
                            val68snr = math.mean(refSetsnr) - t68snr * (math.std(refSetsnr) / math.sqrt(refSetActive.length))
                            t95snr = jStat.studentt.inv(1 - critVal, refSetActive.length - 1)
                            val95snr = math.mean(refSetsnr) - t95snr * (math.std(refSetsnr) / math.sqrt(refSetActive.length))
                            val95snr_text = (val95snr / 10 ** snr_pow).toFixed(2) + snr_pow_text
                            if (tmp_z > 0) {
                                tmp_z = 0
                            }
                            if (tmp_z < max_t) {
                                tmp_z = max_t
                            }
                            tmp_z = tmp_z / max_t
                            snrScore_tmp = 1000 - (1000 * tmp_z)
                        } else {
                            refsetTD5.innerHTML += "N/A"
                        }


                        refsetTD4 = document.createElement("td")
                        if (refSetActive.length > 1) {
                            refsetTD4.innerHTML += (pw_av_rmsd[i]).toFixed(3)

                        } else {
                            refsetTD4.innerHTML += "N/A"
                        }

                        refsetTD7 = document.createElement("td")

                        simple_refsetTD7 = document.createElement("td")

                        if (refSetActive.length > 1 && Object.keys(batches).length - refSetActive.length - inactive.length > 0) {
                            if (refSetActive.length == 2) {
                                tmp_z = 0
                                val68 = pw_av_zscore[i]
                                val95 = pw_av_zscore[i]


                            } else {

                                tmp_score = tscoreTwoSample(pw_zscore_mean, math.mean(refScore_all[i]), pw_zscore_std, math.std(refScore_all[i]), refScore.length, refScore_all[i].length)

                                tmp_ci = jStat.tci(0, 0.05, refScore_all[i])


                                /* if(math.mean(refScore_all[i])+tmp_ci[1]>(pw_zscore_mean+1.5*pw_zscore_std)){
                                    allFails.push(false)
                                }else{
                                    allFails.push(false)
                                } */

                                tmp_dof = twoSampDOF(pw_zscore_std, math.std(refScore_all[i]), refScore.length, refScore_all[i].length)
                                tmp_z = compute(tmp_score, tmp_dof)
                                tmp_z = tmp_score
                                max_t = jStat.studentt.inv(0.0001, tmp_dof)
                                t68 = jStat.studentt.inv(1 - 0.68, tmp_dof)
                                val68 = pw_zscore_mean - t68 * (pw_zscore_std / math.sqrt(refScore.length))
                                t95 = jStat.studentt.inv(1 - critVal, tmp_dof)
                                val95 = pw_zscore_mean - t95 * (pw_zscore_std / math.sqrt(refScore.length))
                                val95_text = (val95 / 10 ** z_score_pow).toFixed(2) + zscore_pow_text

                                if (tmp_z > 0) {
                                    tmp_z = 0
                                }
                                if (tmp_z < max_t) {
                                    tmp_z = max_t
                                }
                                tmp_z = tmp_z / max_t
                            }

                            refsetTD7.innerHTML = "REF"
                            simple_refsetTD7.innerHTML = "REF"
                        } else {
                            refsetTD7.innerHTML += "N/A"
                            simple_refsetTD7.innerHTML = "N/A"
                        }

                        refsetTD3 = document.createElement("td")
                        if (refSetActive.length > 1) {
                            refsetTD3.innerHTML += pw_av_zscore_text[i]
                            if (pw_av_zscore[i] - pw_zscore_mean > equivMult * pw_zscore_std) {
                                refsetTD.setAttribute("style", "color:red")
                                refsetTD3.setAttribute("style", "color:red")
                                refsetTD4.setAttribute("style", "color:red")
                                refsetTD5.setAttribute("style", "color:red")
                            }
                        } else {
                            refsetTD3.innerHTML += "N/A"
                        }
                        if (qcmode) {
                            refsetTD.setAttribute("style", "color:blue;")
                            refsetTD3.setAttribute("style", "color:blue;")
                            refsetTD4.setAttribute("style", "color:blue;")
                            refsetTD5.setAttribute("style", "color:blue;")
                            refsetTD7.setAttribute("style", "color:blue;")

                            simple_refsetTD.setAttribute("style", "color:blue;")
                            simple_refsetTD7.setAttribute("style", "color:blue;")
                        }
                        refsetTD2 = document.createElement("td")
                        refsetChk = document.createElement("input")
                        refsetChk.setAttribute("type", "checkbox")
                        refsetTD2.setAttribute("style", "text-align:center")
                        refsetChk.id = "refchk-" + batches[key].name
                        refsetChk.checked = true
                        refsetChk.addEventListener("click", function () { refSetMod() })
                        refsetTD2.appendChild(refsetChk)

                        simple_refsetTD2 = document.createElement("td")
                        simple_refsetChk = document.createElement("input")
                        simple_refsetChk.setAttribute("type", "checkbox")
                        simple_refsetTD2.setAttribute("style", "text-align:center")
                        simple_refsetChk.id = "refchkS-" + batches[key].name
                        simple_refsetChk.checked = true
                        simple_refsetChk.addEventListener("click", function () { refSetModSimple() })
                        simple_refsetTD2.appendChild(simple_refsetChk)

                        simple_refsetTr.appendChild(simple_refsetTD)
                        simple_refsetTr.appendChild(simple_refsetTD7)
                        if (qcmode) {
                            simple_refsetTr.appendChild(simple_refsetTD2)
                        }
                        simple_refsetTD7.style["text-align"] = "right"
                        simple_refsetTBody.appendChild(simple_refsetTr)


                        refsetTr.appendChild(refsetTD6)
                        refsetTr.appendChild(refsetTD)
                        refsetTr.appendChild(refsetTD5)

                        refsetTr.appendChild(refsetTD3)
                        refsetTr.appendChild(refsetTD7)
                        refsetTD6.setAttribute("class", "notPrinted")
                        refsetTD2.setAttribute("class", "notPrinted")

                        refsetTD3.style["text-align"] = "right"
                        refsetTD5.style["text-align"] = "right"
                        refsetTD7.style["text-align"] = "right"

                        if (qcmode) {
                            refsetTr.appendChild(refsetTD2)
                        }
                        refsetTBody.appendChild(refsetTr)

                        printTable[i][0] = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:10px;width:10px;'></span> B" + batches_l[i].name+": "+batches_l[i].userName
                        printTable[i][1] = refsetTD5.innerHTML
                        printTable[i][2] = refsetTD3.innerHTML
                        printTable[i][3] = refsetTD7.innerHTML

                        printTable[i].color=refsetTD7.style.color

                    } else {
                        index3++;
                        passFlagFail[index3] = "pass";
                        printTable.push({})
                        refsetTr = document.createElement("tr")

                        refsetTD6 = document.createElement("td")
                        newRad = document.createElement("input")
                        newRad.setAttribute('type', "radio");

                        newRad.setAttribute('name', "batchView");
                        newRad.setAttribute('value', "dBaView-" + batches[key].name);
                        newRad.id = "dBaView-" + batches[key].name
                        index2++
                        if (index2 == focus) {
                            newRad.checked = true
                        } else {
                            newRad.checked = false
                        }
                        newRad.addEventListener('click', function () {
                            for (i = 0; i < batches_l.length; i++) {
                                if (document.getElementById("dBaView-" + batches_l[i].name).checked) {
                                    focus = i + 0
                                }
                            }
                            drawDiffPlot(all_confs, all_differences, all_overlaps, olwl, batches_l, focus)
                        }, false)
                        refsetTD6.appendChild(newRad)

                        refsetTD = document.createElement("td")
                        refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                        refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName
                        refsetTD5 = document.createElement("td")



                        simple_refsetTD = document.createElement("td")
                        simple_refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                        simple_refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName

                        if (refSetActive.length > 1) {
                            refsetTD5.innerHTML += all_snr_text[i]
                            tmp_score = tscoreSingle(math.mean(refSetsnr), all_snr[i], math.std(refSetsnr), refSetsnr.length)



                            tmp_z = compute(tmp_score, refSetsnr.length - 1)
                            tmp_z = tmp_score
                            max_t = jStat.studentt.inv(0.0001, refSetsnr.length - 1)
                            t68snr = jStat.studentt.inv(1 - 0.68, refSetsnr.length - 1)
                            val68snr = math.mean(refSetsnr) - t68snr * (math.std(refSetsnr) / math.sqrt(refSetsnr.length))
                            t95snr = jStat.studentt.inv(1 - critVal, refSetsnr.length - 1)
                            val95snr = math.mean(refSetsnr) - t95snr * (math.std(refSetsnr) / math.sqrt(refSetsnr.length))
                            val95snr_text = (val95snr / 10 ** snr_pow).toFixed(2) + snr_pow_text
                            if (tmp_z > 0) {
                                tmp_z = 0
                            }
                            if (tmp_z < max_t) {
                                tmp_z = max_t
                            }
                            tmp_z = tmp_z / max_t
                            snrScore_tmp = 1000 - (1000 * tmp_z)
                            if (all_snr[i] > val95snr) {
                                passFlagFail[index3] = "flag";
                            }
                        } else {
                            refsetTD5.innerHTML += "N/A"
                        }

                        refsetTD4 = document.createElement("td")
                        if (refSetActive.length > 1) {
                            refsetTD4.innerHTML += (pw_av_rmsd[i]).toFixed(3)

                        } else {
                            refsetTD4.innerHTML += "N/A"
                        }

                        t_flag = false

                        refsetTD7 = document.createElement("td")
                        simple_refsetTD7 = document.createElement("td")

                        dist_fail = false
                        if (refSetActive.length > 1 && Object.keys(batches).length - refSetActive.length - inactive.length > 0) {

                            tmp_score = tscoreTwoSample(pw_zscore_mean, math.mean(vsScore_all[i]), pw_zscore_std, math.std(vsScore_all[i]), refScore.length, vsScore_all[i].length)


                            tmp_ci = diffCI(pw_zscore_mean, math.mean(vsScore_all[i]), pw_zscore_std, math.std(vsScore_all[i]), refScore.length, vsScore_all[i].length, 0.1)
                            allScoreCI.push(tmp_ci[1])
                            if (math.mean(vsScore_all[i]) - pw_zscore_mean + tmp_ci[1] > (equivMult * pw_zscore_std)) {
                                allFails.push(true)
                                passFlagFail[index3] = "fail"
                                dist_fail = true
                            } else {
                                allFails.push(false)
                            }



                            tmp_dof = twoSampDOF(pw_zscore_std, math.std(vsScore_all[i]), refScore.length, vsScore_all[i].length)
                            tmp_z = compute(tmp_score, tmp_dof)
                            tmp_z = tmp_score
                            max_t = jStat.studentt.inv(0.0001, tmp_dof)
                            t95 = jStat.studentt.inv(1 - critVal, tmp_dof)
                            t68 = jStat.studentt.inv(1 - 0.68, tmp_dof)
                            val68 = pw_zscore_mean - t68 * (pw_zscore_std / math.sqrt(refScore.length))

                            val95 = pw_zscore_mean - t95 * (pw_zscore_std / math.sqrt(refScore.length))
                            val95_text = (val95 / 10 ** z_score_pow).toFixed(2) + zscore_pow_text

                            if (tmp_z > 0) {
                                tmp_z = 0
                            }
                            if (tmp_z < max_t) {
                                tmp_z = max_t
                            }
                            tmp_z = tmp_z / max_t

                            if (dist_fail) {
                                refsetTD7.innerHTML = "DIFFERENT"
                                simple_refsetTD7.innerHTML = "DIFFERENT"
                            } else {
                                refsetTD7.innerHTML = "SAME"
                                simple_refsetTD7.innerHTML = "SAME"
                            }

                            all_zscores.push(Math.round((1000 - (1000 * tmp_z) + snrScore_tmp) / 2))
                        } else {
                            refsetTD7.innerHTML += "N/A"
                            simple_refsetTD7.innerHTML = "N/A"
                        }


                        refsetTD3 = document.createElement("td")
                        if (refSetActive.length > 1) {
                            refsetTD3.innerHTML += pw_av_zscore_text[i]
                            if (dist_fail) {
                                refsetTD.setAttribute("style", "color:red")
                                refsetTD3.setAttribute("style", "color:red")
                                refsetTD4.setAttribute("style", "color:red")

                                refsetTD7.setAttribute("style", "color:red")

                                simple_refsetTD.setAttribute("style", "color:red;")
                                simple_refsetTD7.setAttribute("style", "color:red;")
                                if (all_snr[i] > val95snr) {

                                    refsetTD5.setAttribute("style", "color:red")

                                }
                            } else {
                                if (all_snr[i] > val95snr) {

                                    refsetTD.setAttribute("style", "color:rgb(249, 8, 234)")
                                    refsetTD5.setAttribute("style", "color:rgb(249, 8, 234)")

                                    refsetTD7.setAttribute("style", "color:rgb(249, 8, 234)")
                                    refsetTD7.innerHTML = "FLAG"
                                    simple_refsetTD7.innerHTML = "FLAG"
                                    simple_refsetTD.setAttribute("style", "color:rgb(249, 8, 234);")
                                    simple_refsetTD7.setAttribute("style", "color:rgb(249, 8, 234);")

                                }
                            }

                        } else {
                            refsetTD3.innerHTML += "N/A"
                        }


                        refsetTD2 = document.createElement("td")
                        refsetChk = document.createElement("input")
                        refsetChk.setAttribute("type", "checkbox")
                        refsetTD2.setAttribute("style", "text-align:center")
                        refsetChk.id = "refchk-" + batches[key].name
                        refsetChk.checked = false
                        refsetChk.addEventListener("click", function () { refSetMod() })
                        refsetTD2.appendChild(refsetChk)

                        simple_refsetTD2 = document.createElement("td")
                        simple_refsetChk = document.createElement("input")
                        simple_refsetChk.setAttribute("type", "checkbox")
                        simple_refsetTD2.setAttribute("style", "text-align:center")
                        simple_refsetChk.id = "refchkS-" + batches[key].name
                        simple_refsetChk.checked = false
                        simple_refsetChk.addEventListener("click", function () { refSetModSimple() })
                        simple_refsetTD2.appendChild(simple_refsetChk)

                        simple_refsetTr.appendChild(simple_refsetTD)
                        simple_refsetTr.appendChild(simple_refsetTD7)
                        if (qcmode) {
                            simple_refsetTr.appendChild(simple_refsetTD2)
                        }
                        simple_refsetTD7.style["text-align"] = "right"
                        simple_refsetTBody.appendChild(simple_refsetTr)


                        refsetTr.appendChild(refsetTD6)
                        refsetTr.appendChild(refsetTD)
                        refsetTr.appendChild(refsetTD5)

                        refsetTr.appendChild(refsetTD3)
                        refsetTr.appendChild(refsetTD7)
                        refsetTD6.setAttribute("class", "notPrinted")
                        refsetTD2.setAttribute("class", "notPrinted")

                        refsetTD3.style["text-align"] = "right"
                        refsetTD5.style["text-align"] = "right"
                        refsetTD7.style["text-align"] = "right"

                        if (qcmode) {
                            refsetTr.appendChild(refsetTD2)
                        }
                        refsetTBody.appendChild(refsetTr)
                        printTable[i][0] = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:10px;width:10px;'></span> B" + batches_l[i].name+": "+batches_l[i].userName
                        printTable[i][1] = refsetTD5.innerHTML
                        printTable[i][2] = refsetTD3.innerHTML
                        printTable[i][3] = refsetTD7.innerHTML

                        printTable[i].color=refsetTD7.style.color

                    }
                    refsetTable.appendChild(refsetTBody)
                    simple_refsetTable.appendChild(simple_refsetTBody)
                    i++
                    
                }
            })
        } else {
            equivSlide = slider_equiv.noUiSlider.get();
            equivMult=parseFloat(equivSlide)
            let eMessage=document.getElementsByClassName("equiv-message")
            eMessage[0].innerHTML=""
            eMessage[1].innerHTML=""

            refScore = []
            refNames = []
            vsScore = []
            vsScore_all = []
            refScore_all = []
            vsNames = []
            vsNamesLong= []

            for (ppp = 0; ppp < pw_zscore.length; ppp++) {
                vsScore_all_tmp = []
                refScore_all_tmp = []
                for (qqq = 0; qqq < pw_zscore[ppp].length; qqq++) {
                    if (qqq != ppp) {
                        if (pw_zscore[ppp][qqq] != 0) {
                            if (vsScore.includes(pw_zscore[ppp][qqq]) == false) {
                                vsScore.push((pw_zscore[ppp][qqq]))
                            }

                            vsScore_all_tmp.push((pw_zscore[ppp][qqq]))
                        }


                    }
                }
                vsScore_all.push(vsScore_all_tmp)
                vsNamesLong.push(x[ppp] + ": "+batches_l[ppp].userName)
                vsNames.push(x[ppp])

                for (qqq = 0; qqq < pw_zscore.length; qqq++) {

                    for (rrr = 0; rrr < pw_zscore[qqq].length; rrr++) {
                        if (rrr != ppp && qqq != ppp && rrr < qqq) {
                            refScore_all_tmp.push(pw_zscore[qqq][rrr])
                        }
                    }


                }
                refScore_all.push(refScore_all_tmp)


            }

            /* equivMultNONQC=[]
            for(let g=0;g<refScore_all.length;g++){
                tmp_Max=0
                if(refScore_all[g].length>0){

                    tmp_mean=refMeans[g]
                    tmp_ci = tmp_ci = diffCI(math.mean(refScore_all[i]), math.mean(vsScore_all[i]), math.std(refScore_all[i]), math.std(vsScore_all[i]), refScore_all[i].length, vsScore_all[i].length, 0.1)
                    tmp_combo = tmp_mean+tmp_ci[1]
                    if(tmp_Max<tmp_combo){
                        tmp_Max=tmp_combo+0
                    }
                }
                if(tmp_Max>0){
                    equivMult=(tmp_Max-tmp_mean)/pw_zscore_std
                    equivMult=parseFloat(equivMult.toFixed(3))
                    if(equivMult<1.5){
                        equivMult=1.5
                    }
                }
            }
             */

            deviations = math.abs(math.subtract(math.median(pw_av_zscore), pw_av_zscore))
            madev = math.median(deviations) * 1.4826 // correction so as to be estimator of sd for normal distribution
            Object.keys(batches).forEach(function (key, index) {
                if (inactive.includes(key) == false) {

                    passFlagFail[i] = "pass"
                    printTable.push({})

                    refsetTr = document.createElement("tr")
                    simple_refsetTr = document.createElement("tr")

                    refsetTD6 = document.createElement("td")
                    newRad = document.createElement("input")
                    newRad.setAttribute('type', "radio");

                    newRad.setAttribute('name', "batchView");
                    newRad.setAttribute('value', "dBaView-" + batches[key].name);
                    newRad.id = "dBaView-" + batches[key].name
                    index2++
                    if (index2 == focus) {
                        newRad.checked = true
                    } else {
                        newRad.checked = false
                    }
                    newRad.addEventListener('click', function () {
                        for (i = 0; i < batches_l.length; i++) {
                            if (document.getElementById("dBaView-" + batches_l[i].name).checked) {
                                focus = i + 0
                            }
                        }
                        drawDiffPlot(all_confs, all_differences, all_overlaps, olwl, batches_l, focus)
                    }, false)
                    refsetTD6.appendChild(newRad)

                    refsetTD = document.createElement("td")
                    refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                    refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName
                    refsetTD5 = document.createElement("td")

                    simple_refsetTD = document.createElement("td")
                    simple_refsetTD.innerHTML = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:15px;width:15px;'></span>"
                    simple_refsetTD.innerHTML += "B" + batches_l[i].name + ": "+batches_l[i].userName

                    refsetTD5.innerHTML += all_snr_text[i]
                    if (Object.keys(batches).length - inactive.length > 1) {
                        tmp_score = tscoreSingle(math.mean(all_snr), all_snr[i], math.std(all_snr), all_snr.length)
                        tmp_z = compute(tmp_score, all_snr.length - 1)
                        tmp_z = tmp_score
                        max_t = jStat.studentt.inv(0.0001, all_snr.length - 1)
                        t68snr = jStat.studentt.inv(1 - 0.68, all_snr.length - 1)
                        val68snr = math.mean(all_snr) - t68snr * (math.std(all_snr) / math.sqrt(all_snr.length))
                        t95snr = jStat.studentt.inv(1 - critVal, all_snr.length - 1)
                        val95snr = math.mean(all_snr) - t95snr * (math.std(all_snr) / math.sqrt(all_snr.length))
                        val95snr_text = (val95snr / 10 ** snr_pow).toFixed(2) + snr_pow_text
                        if (tmp_z > 0) {
                            tmp_z = 0
                        }
                        if (tmp_z < max_t) {
                            tmp_z = max_t
                        }
                        if (all_snr[i] > val95snr) {
                            passFlagFail[i] = "flag"
                        }
                        tmp_z = tmp_z / max_t
                        snrScore_tmp = 1000 - (1000 * tmp_z)
                    }

                    refsetTD3 = document.createElement("td")
                    refsetTD3.innerHTML += pw_av_zscore_text[i]
                    refsetTD4 = document.createElement("td")

                    refsetTD4.innerHTML += (pw_av_rmsd[i]).toFixed(3)

                    refsetTD7 = document.createElement("td")
                    simple_refsetTD7 = document.createElement("td")
                    dist_fail = false
                    if (Object.keys(batches).length - inactive.length > 2) {

                        tmp_score = tscoreSingle(math.mean(pw_av_zscore), pw_av_zscore[i], math.std(pw_av_zscore), pw_av_zscore.length)
                        tmp_z = compute(tmp_score, pw_av_zscore.length - 1)

                        tmp_ci = diffCI(math.mean(refScore_all[i]), math.mean(vsScore_all[i]), math.std(refScore_all[i]), math.std(vsScore_all[i]), refScore_all[i].length, vsScore_all[i].length, 0.1)
                        allScoreCI.push(tmp_ci[1])
                        if (math.mean(vsScore_all[i]) - math.mean(refScore_all[i]) + tmp_ci[1] > (equivMult * math.std(refScore_all[i]))) {
                            allFails.push(true)
                            passFlagFail[i] = "fail"
                            dist_fail = true
                        } else {
                            allFails.push(false)
                        }

                        tmp_z = tmp_score
                        max_t = jStat.studentt.inv(0.0001, pw_av_zscore.length - 1)
                        t68 = jStat.studentt.inv(1 - 0.68, pw_av_zscore.length - 1)
                        val68 = math.mean(pw_av_zscore) - t68 * (math.std(pw_av_zscore) / math.sqrt(pw_av_zscore.length))
                        t95 = jStat.studentt.inv(1 - critVal, pw_av_zscore.length - 1)
                        val95 = math.mean(pw_av_zscore) - t95 * (math.std(pw_av_zscore) / math.sqrt(pw_av_zscore.length))
                        val95_text = (val95 / 10 ** z_score_pow).toFixed(2) + zscore_pow_text

                        if (tmp_z > 0) {
                            tmp_z = 0
                        }
                        if (tmp_z < max_t) {
                            tmp_z = max_t
                        }
                        tmp_z = tmp_z / max_t


                        all_zscores.push(Math.round((1000 - (1000 * tmp_z) + snrScore_tmp) / 2))

                        if (dist_fail) {
                            refsetTD7.innerHTML = "DIFFERENT"
                            simple_refsetTD7.innerHTML = "DIFFERENT"
                        } else {
                            refsetTD7.innerHTML = "SAME"
                            simple_refsetTD7.innerHTML = "SAME"
                        }
                    } else {
                        refsetTD7.innerHTML = "N/A"
                        simple_refsetTD7.innerHTML = "N/A"
                    }
                    if (Object.keys(batches).length - inactive.length > 2) {
                        if (dist_fail) {
                            refsetTD.setAttribute("style", "color:red")
                            refsetTD3.setAttribute("style", "color:red")
                            refsetTD4.setAttribute("style", "color:red")

                            refsetTD7.setAttribute("style", "color:red")

                            simple_refsetTD7.setAttribute("style", "color:red")
                            simple_refsetTD.setAttribute("style", "color:red")

                            if (all_snr[i] > val95snr) {

                                refsetTD5.setAttribute("style", "color:red")

                            }
                        } else {
                            if (all_snr[i] > val95snr) {

                                refsetTD.setAttribute("style", "color:rgb(249, 8, 234)")
                                refsetTD5.setAttribute("style", "color:rgb(249, 8, 234)")

                                refsetTD7.setAttribute("style", "color:rgb(249, 8, 234)")
                                refsetTD7.innerHTML = "FLAG"
                                simple_refsetTD7.innerHTML = "FLAG"
                                simple_refsetTD.setAttribute("style", "color:rgb(249, 8, 234);")
                                simple_refsetTD7.setAttribute("style", "color:rgb(249, 8, 234);")

                            }
                        }
                    }


                    refsetTD2 = document.createElement("td")
                    refsetChk = document.createElement("input")
                    refsetChk.setAttribute("type", "checkbox")
                    refsetTD2.setAttribute("style", "text-align:center")
                    refsetChk.id = "refchk-" + batches[key].name
                    refsetChk.checked = true
                    refsetChk.addEventListener("click", function () { refSetMod() })
                    refsetTD2.appendChild(refsetChk)


                    simple_refsetTD2 = document.createElement("td")
                    simple_refsetChk = document.createElement("input")
                    simple_refsetChk.setAttribute("type", "checkbox")
                    simple_refsetTD2.setAttribute("style", "text-align:center")
                    simple_refsetChk.id = "refchkS-" + batches[key].name
                    simple_refsetChk.checked = true
                    simple_refsetChk.addEventListener("click", function () { refSetModSimple() })
                    simple_refsetTD2.appendChild(simple_refsetChk)

                    simple_refsetTr.appendChild(simple_refsetTD)
                    simple_refsetTr.appendChild(simple_refsetTD7)
                    if (qcmode) {
                        simple_refsetTr.appendChild(simple_refsetTD2)
                    }
                    simple_refsetTD7.style["text-align"] = "right"
                    simple_refsetTBody.appendChild(simple_refsetTr)
                    simple_refsetTable.appendChild(simple_refsetTBody)



                    refsetTr.appendChild(refsetTD6)
                    refsetTr.appendChild(refsetTD)
                    refsetTr.appendChild(refsetTD5)

                    refsetTr.appendChild(refsetTD3)
                    refsetTr.appendChild(refsetTD7)
                    refsetTD6.setAttribute("class", "notPrinted")
                    refsetTD2.setAttribute("class", "notPrinted")

                    refsetTD3.style["text-align"] = "right"
                    refsetTD5.style["text-align"] = "right"
                    refsetTD7.style["text-align"] = "right"

                    if (qcmode) {
                        refsetTr.appendChild(refsetTD2)
                    }
                    refsetTBody.appendChild(refsetTr)

                    printTable[i][0] = "<span class='dot' style='background-color:" + colScheme[(index + 1) % colScheme.length] + "; height:10px;width:10px;'></span> B" + batches_l[i].name+": "+batches_l[i].userName
                    printTable[i][1] = refsetTD5.innerHTML
                    printTable[i][2] = refsetTD3.innerHTML
                    printTable[i][3] = refsetTD7.innerHTML

                    printTable[i].color=refsetTD7.style.color


                    refsetTable.appendChild(refsetTBody)
                    i++
                }


            });


        }
        document.getElementById("refSetOptions").appendChild(refsetTable)
        document.getElementById("refSetOptionsSimp").appendChild(simple_refsetTable)




        function rmsd(arr1, arr2) {
            diff = math.subtract(arr1, arr2)
            diff_2 = math.square(diff)
            diff_2_m = math.mean(diff_2)
            diff_2_m_rt = math.sqrt(diff_2_m)

            return ([diff_2_m_rt, math.abs(diff)])
        }

        averageRMSD = (math.sum(z_dev) / ((batches_l.length) ** 2 - (batches_l.length))).toFixed(2)
        data_hm2 = [
            {
                z: z_dev.slice().reverse(),
                x: x,
                y: y.slice(),
                type: 'heatmap',
                colorscale: [


                    ['0.0', 'rgb(19, 214, 45)'],
                    ['0.25', 'rgb(240, 247, 43)'],
                    ['0.5', 'rgb(247, 233, 44)'],
                    ['0.75', 'rgb(247, 103, 37)'],
                    ['1.0', 'rgb(247, 43, 43)']
                ],//mode["RMSD"].colorScale,
                zmin: 0,
                zmax: dev_t,


            }
        ];


        if (metric == "stderr") {
            score1 = (((math.sum(z_overlap) - batches_l.length) / (batches_l.length ** 2 - batches_l.length))) * 1000
        }
        else if (metric == "confInt") {
            score1 = (((math.sum(z_overlap)) / (batches_l.length ** 2 - batches_l.length))) * 1000
            score2 = z_score * 1000//(((math.sum(z_score))/(batches_l.length**2-batches_l.length)))*1000//**1.05
            if (score2 > 1000) {
                score2 = 1000
            }
        }
        if (batches_l.length < 2) {
            score = "NA"
            document.getElementById("score").innerHTML = "NA% differen15ce<br> <small><small>Add data above</small></small>"

        } else {
            if (refSetActive.length > 1) {
                lower = ((pw_zscore_mean) - 3 * (pw_zscore_std))
                upper = ((pw_zscore_mean) + 3 * (pw_zscore_std))
                if (upper > 1000) {
                    upper = 1000
                }
                if (lower < 0) {
                    lower = 0
                }
            }

            refSetFactsText = "<table style='width:100%'><tbody>"
            if (refSetActive.length > 1) {
                refSetFactsText += "<tr><td>Reference Set Average Score:</td><td>" + pw_zscore_mean.toFixed(0) + "</td></tr>"
                refSetFactsText += "<tr><td>3 Sigma Lower Bound:</td><td>" + lower + "</td></tr>"
            } else {
                refSetFactsText += "<tr><td>Reference Set Average Score:</td><td>N/A</td></tr>"
                refSetFactsText += "<tr><td>3 Sigma Lower Bound:</td><td>N/A</td></tr>"
            }
            refSetFactsText += "</tbody></table>"
            if (qcmode) {
                document.getElementById("refSetFacts").innerHTML = refSetFactsText
            }
            if (metric == "confInt") {
                score = String(Math.round(score1) / 10)
                document.getElementById("score").innerHTML = score + "<small>% difference<br><small>with " + (1 - alpha) * 100 + "% confidence</small></small>"

            } else {
                score = String(Math.round(score1) / 10)
                document.getElementById("score").innerHTML = score + "<small>% Similarity<br><small>with 95% confidence</small></small>"
            }

        }



        if (Object.keys(batches).length - inactive.length < 3 || refSetActive.length < 2) {
            if (qcmode) {

                document.getElementById("plotly-divsig").setAttribute('style', 'display:none')
                document.getElementById("plotly-divsnr").setAttribute('style', 'display:none')
                document.getElementById("plotly-divsig-S").setAttribute('style', 'display:none')
                document.getElementById("plotly-divsnr-S").setAttribute('style', 'display:none')
                document.getElementById("nonQC").setAttribute('style', "display:none")
                document.getElementById("QC1").style.display = null
                document.getElementById("QC2").style.display = null

                document.getElementById("scoreBallRef").setAttribute('style', "display:none")
                document.getElementById("overallScoreRef").innerHTML = "<td><i>Av. Spectral Difference</i></td><td>XXXX</td>"
                document.getElementById("overallScoreSNR").innerHTML = "<td><i>Standard Error</i></td><td>XXXX</td>"

                document.getElementById("scoreBallVs").setAttribute('style', "background-color:#bbb")
                document.getElementById("overallScoreVs").innerHTML = "XXXX"

            } else {

                if (Object.keys(batches).length - inactive.length < 3) {
                    document.getElementById("plotly-divsig").setAttribute('style', 'display:none')
                    document.getElementById("plotly-divsnr").setAttribute('style', 'display:none')
                    document.getElementById("plotly-divsig-S").setAttribute('style', 'display:none')
                    document.getElementById("plotly-divsnr-S").setAttribute('style', 'display:none')
                    document.getElementById("overallScoreRef").innerHTML = "<td><i>Av. Spectral Difference</i></td><td>XXXX</td>"
                    document.getElementById("overallScoreSNR").innerHTML = "<td><i>Standard Error</i></td><td>XXXX</td>"
                }
                document.getElementById("nonQC").style.display = null

                document.getElementById("QC2").setAttribute('style', "display:none")
                document.getElementById("scoreBall").setAttribute('style', "background-color:#bbb")
                document.getElementById("overallScore").innerHTML = "XXXX"

            }

        } else {

            if (qcmode) {

                data_sig = []


                vsColors = []
                vsSymbols = []
                for (uuu = 0; uuu < allFails.length; uuu++) {
                    if (allFails[uuu]) {
                        vsColors.push("red")
                        vsSymbols.push("x")
                    } else {
                        vsColors.push("black")
                        vsSymbols.push("x")
                    }
                }


                data_sig.push({
                    type: 'scatter',
                    x: math.subtract(vsScore, pw_zscore_mean).slice().reverse(),
                    y: vsNames.slice().reverse(),
                    error_x: {
                        type: 'data',
                        array: allScoreCI.slice().reverse(),
                        visible: true,
                    },
                    hovertemplate: "%{text}: %{x} <extra></extra>",
                    text: vsNamesLong.slice().reverse(),
                    mode: 'markers',
                    marker: {
                        size: 8,
                        color: vsColors.slice().reverse(),
                        symbol: vsSymbols.slice().reverse(),
                    },


                })
                if (vsScore.length > 0) {
                    layoutsig = {
                        colorway: colScheme,
                        paper_bgcolor: "rgb(255,255,255)",
                        plot_bgcolor: "rgb(255,255,255)",
                        autosize: false,
                        width: 900,
                        height: 400,
                        margin: {
                            t: 30,
                            b: 50,
                            r: 5,
                            l: 50
                        },
                        hovermode: 'closest',
                        hoverlabel: {
                            bgcolor: "white",
                        },
                        showlegend: false,
                        dragmode: 'pan',
                        xaxis: {

                            gridcolor: "rgb(229,229,229)",

                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: true,
                            fixedrange: true,


                        },
                        yaxis: {

                            tickfont: { size: 10 },

                            exponentformat: "power",
                            showexponent: "all",
                            rangemode: "nonnegative",
                            gridcolor: "rgb(229,229,229)",
                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: false,
                            fixedrange: true
                        }

                    };

                    layoutsigSimp = {
                        colorway: colScheme,
                        paper_bgcolor: "rgb(255,255,255)",
                        plot_bgcolor: "rgb(255,255,255)",
                        autosize: false,
                        width: 1200,
                        height: 300,
                        margin: {
                            t: 30,
                            b: 50,
                            r: 5,
                            l: 50
                        },
                        hovermode: 'closest',
                        hoverlabel: {
                            bgcolor: "white",
                        },
                        showlegend: false,
                        dragmode: 'pan',
                        xaxis: {

                            gridcolor: "rgb(229,229,229)",

                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: true,
                            fixedrange: true,


                        },
                        yaxis: {

                            tickfont: { size: 10 },

                            exponentformat: "power",
                            showexponent: "all",
                            rangemode: "nonnegative",
                            gridcolor: "rgb(229,229,229)",
                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: false,
                            fixedrange: true
                        }

                    };
                }
                sig_annotations = [{
                    xref: 'x',
                    yref: 'paper',
                    x: equivMult * pw_zscore_std * 0.9,
                    xanchor: 'right',
                    y: 1.0,
                    yanchor: 'top',
                    text: 'SAME',
                    showarrow: false,
                    font: {

                        size: 16,
                        color: 'black'
                    },
                }, {
                    xref: 'x',
                    yref: 'paper',
                    x: equivMult * pw_zscore_std * 1.1,
                    xanchor: 'left',
                    y: 1.0,
                    yanchor: 'top',
                    text: 'DIFFERENT',
                    showarrow: false,
                    font: {

                        size: 16,
                        color: 'red'
                    },
                }, {

                    yref: 'paper',
                    x: equivMult * pw_zscore_std,
                    xanchor: 'center',
                    y: 1.0,
                    yanchor: 'bottom',
                    text: equivMult+'<sub>ref</sub>: ' + math.round(equivMult * pw_zscore_std, 3),
                    showarrow: false,
                    font: {

                        size: 16,
                        color: 'blue'
                    },
                }]

                sig_shapes = [];

                sig_shapes.push(
                    {
                        type: 'line',
                        yref: 'paper',
                        x0: equivMult * pw_zscore_std,
                        y0: 0,
                        x1: equivMult * pw_zscore_std,
                        y1: 1,
                        line: {
                            color: 'blue',
                            width: 4,
                            dash: 'dot'
                        },
                        layer: "below"
                    }
                )

                layoutsig.shapes = sig_shapes
                layoutsigSimp.shapes = sig_shapes

                layoutsig.annotations = sig_annotations
                layoutsigSimp.annotations = sig_annotations
            } else {
                data_sig = []


                vsColors = []
                vsSymbols = []
                for (uuu = 0; uuu < allFails.length; uuu++) {
                    if (allFails[uuu]) {
                        vsColors.push("red")
                        vsSymbols.push("x")
                    } else {
                        vsColors.push("black")
                        vsSymbols.push("x")
                    }
                }

                vsMeans = []
                refMeans = []
                refStd = []

                for (uuu = 0; uuu < vsScore_all.length; uuu++) {
                    vsMeans.push(math.mean(vsScore_all[uuu]))
                    refMeans.push(math.mean(refScore_all[uuu]))
                    refStd.push(math.std(refScore_all[uuu]))
                }

                data_sig.push({
                    type: 'scatter',
                    x: math.subtract(vsMeans, refMeans).slice().reverse(),
                    y: vsNames.slice().reverse(),
                    error_x: {
                        type: 'data',
                        array: allScoreCI.slice().reverse(),
                        visible: true,
                    },
                    hovertemplate: "%{text}: %{x} <extra></extra>",
                    text: vsNamesLong.slice().reverse(),
                    mode: 'markers',
                    marker: {
                        size: 8,
                        color: vsColors.slice().reverse(),
                        symbol: vsSymbols.slice().reverse(),
                    },


                })

                data_sig.push({
                    type: 'scatter',
                    x: math.multiply(refStd, equivMult).slice().reverse(),
                    y: vsNames.slice().reverse(),

                    hovertemplate: equivMult+"<sub>ref</sub>: %{x} <extra></extra>",
                    text: vsNamesLong.slice().reverse(),
                    mode: 'markers',
                    marker: {
                        size: math.round(120 / vsNames.length),
                        color: "blue",
                        symbol: "line-ns-open",
                        line: { width: 3 },
                    },
                })

                if (vsScore.length > 0) {
                    layoutsig = {
                        colorway: colScheme,
                        paper_bgcolor: "rgb(255,255,255)",
                        plot_bgcolor: "rgb(255,255,255)",
                        autosize: false,
                        width: 900,
                        height: 400,
                        margin: {
                            t: 30,
                            b: 50,
                            r: 5,
                            l: 50
                        },
                        hovermode: 'closest',
                        hoverlabel: {
                            bgcolor: "white",
                        },
                        showlegend: false,
                        dragmode: 'pan',
                        xaxis: {

                            gridcolor: "rgb(229,229,229)",

                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: true,
                            fixedrange: true,


                        },
                        yaxis: {

                            tickfont: { size: 10 },

                            exponentformat: "power",
                            showexponent: "all",
                            rangemode: "nonnegative",
                            gridcolor: "rgb(229,229,229)",
                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: false,
                            fixedrange: true
                        }

                    };

                    layoutsigSimp = {
                        colorway: colScheme,
                        paper_bgcolor: "rgb(255,255,255)",
                        plot_bgcolor: "rgb(255,255,255)",
                        autosize: false,
                        width: 1200,
                        height: 300,
                        margin: {
                            t: 30,
                            b: 50,
                            r: 5,
                            l: 50
                        },
                        hovermode: 'closest',
                        hoverlabel: {
                            bgcolor: "white",
                        },
                        showlegend: false,
                        dragmode: 'pan',
                        xaxis: {

                            gridcolor: "rgb(229,229,229)",

                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: true,
                            fixedrange: true,


                        },
                        yaxis: {

                            tickfont: { size: 10 },

                            exponentformat: "power",
                            showexponent: "all",
                            rangemode: "nonnegative",
                            gridcolor: "rgb(229,229,229)",
                            showgrid: true,
                            showline: true,
                            mirror: true,
                            showticklabels: true,
                            tickcolor: "rgb(127,127,127)",
                            ticks: "outside",
                            zeroline: false,
                            fixedrange: true
                        }

                    };
                }
                sig_annotations = [{
                    xref: 'x',
                    yref: 'paper',
                    x: math.min(math.multiply(refStd, equivMult)) * 0.9,
                    xanchor: 'right',
                    y: 1.0,
                    yanchor: 'top',
                    text: 'SAME',
                    showarrow: false,
                    font: {

                        size: 16,
                        color: 'black'
                    },
                }, {
                    xref: 'x',
                    yref: 'paper',
                    x: math.max(math.multiply(refStd, equivMult)) * 1.1,
                    xanchor: 'left',
                    y: 1.0,
                    yanchor: 'top',
                    text: 'DIFFERENT',
                    showarrow: false,
                    font: {

                        size: 16,
                        color: 'red'
                    },
                }]

                layoutsig.annotations = sig_annotations
                layoutsigSimp.annotations = sig_annotations
            }



            if (qcmode) {


                data_snr = []

                data_snr.push({
                    type: 'scatter',
                    x: [-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
                    y: Array(17).fill((val95snr).toExponential(2)),

                    hovertemplate: "%{text}: %{y} <extra></extra>",
                    text: Array(17).fill("P(t) = 95%"),
                    mode: 'markers',
                    marker: {
                        size: 1,
                        opacity: 0,
                        color: "blue",
                        symbol: "triangle-down"
                    },

                })
                data_snr.push({
                    type: 'scatter',
                    x: Array(1).fill(0),
                    y: [math.mean(refSetsnr)],
                    hovertemplate: "Ref. Mean: %{y} <extra></extra>",

                    mode: 'markers',
                    marker: {
                        size: 15,
                        color: "white",
                        symbol: "circle",
                        line: {
                            color: "blue",
                            width: 3
                        }
                    },


                })

                vsColors = []
                vsSymbols = []
                for (uuu = 0; uuu < testSetsnr.length; uuu++) {
                    if (testSetsnr[uuu] > val95snr) {
                        vsColors.push("rgb(249, 8, 234)")
                        vsSymbols.push("x")
                        allDQFails.push(true)
                    } else {
                        vsColors.push("black")
                        vsSymbols.push("x")
                        allDQFails.push(false)
                    }
                }

                data_snr.push({
                    type: 'scatter',
                    x: Array(vsNames.length).fill(0),
                    y: testSetsnr,
                    hovertemplate: "%{text}: %{y} <extra></extra>",
                    text: vsNames,
                    mode: 'markers',
                    marker: {
                        size: 8,
                        color: vsColors,
                        symbol: vsSymbols,
                    },


                })

                //normal dist curve for DQ plot

                max_snr=math.mean(refSetsnr)+(((val95snr-math.mean(refSetsnr))/1.69)*3)
                //min_snr=Math.floor(math.min(testSetsnr)*100)/100
                min_snr=math.mean(refSetsnr)-(((val95snr-math.mean(refSetsnr))/1.69)*3)
                snr_diff=max_snr-min_snr
                normal_curvex=[]
                normal_curvey=[]
                normal_curvex_high=[]
                normal_curvey_high=[]
                for (let r=0;r<100;r++){
                    let normvaly=min_snr+((snr_diff/100)*r)
                    let normvalx=jStat.normal.pdf(normvaly, math.mean(refSetsnr), (val95snr-math.mean(refSetsnr))/1.69)
                    //let normvalx=jStat.studentt.pdf(normvaly, refSetsnr.length)
                    //normvalx=normvalx*math.std(refSetsnr)+math.mean(refSetsnr)
                    if(normvaly<val95snr){
                        normal_curvey.push(normvaly)
                        normal_curvex.push(normvalx)
                    }else{
                        normal_curvey_high.push(normvaly)
                        normal_curvex_high.push(normvalx)
                    }
                    
                }

                normal_curvey_high.unshift(normal_curvey[normal_curvey.length-1])
                normal_curvex_high.unshift(normal_curvex[normal_curvey.length-1])

                normal_curvey_high.unshift(normal_curvey[normal_curvey.length-1])
                normal_curvex_high.unshift(math.min(normal_curvex_high))

                normal_curvey.push(normal_curvey[normal_curvey.length-1])
                normal_curvex.push(math.min(normal_curvex))

                //normal_curvex=math.multiply(math.divide(normal_curvex, math.max(normal_curvex)), 0.8)
                if(testSetsnr.length>0){
                    if(max_snr>math.max(testSetsnr) && min_snr<math.min(testSetsnr)){
                        layoutsnr.yaxis.range=[min_snr,max_snr]
                    }else if(max_snr>math.max(testSetsnr) && min_snr>math.min(testSetsnr)){
                        layoutsnr.yaxis.range=[math.min(testSetsnr)-snr_diff*0.05,max_snr]
                    }else if(max_snr<math.max(testSetsnr) && min_snr<math.min(testSetsnr)){
                        layoutsnr.yaxis.range=[min_snr,math.max(testSetsnr)+snr_diff*0.05]
                    }else{
                        layoutsnr.yaxis.range=[math.min(testSetsnr)-snr_diff*0.05,math.max(testSetsnr)+snr_diff*0.05]
                    }
                }
                
                //layoutsnr.yaxis.range=[min_snr,max_snr]

                data_snr.push({
                    type: 'line',
                    x: normal_curvex,
                    y: normal_curvey,
                    xaxis:"x2",
                    fill: 'tozeroy',
                    line:{
                        color:"lightblue",
                    },
                    hoverinfo:'skip'


                })
                data_snr.push({
                    type: 'line',
                    x: normal_curvex_high,
                    y: normal_curvey_high,
                    xaxis:"x2",
                    fill: 'toself',
                    line:{
                        color:"magenta",
                    },
                    hoverinfo:'skip'


                })

                snr_shapes = []
                snr_shapes.push(
                    {
                        type: 'line',
                        xref: 'paper',
                        x0: 0,
                        y0: val95snr,
                        x1: 1,
                        y1: val95snr,
                        line: {
                            color: 'magenta',
                            width: 3,
                            dash: 'dot'
                        },
                        layer: "below"
                    }
                )
                
                


                layoutsnr.shapes = snr_shapes
            } else {
                data_snr = []
                deviationsSNR = math.abs(math.subtract(math.median(all_snr), all_snr))
                madevSNR = math.median(deviations) * 1.4826 // correction so as to be estimator of sd for normal distribution
                data_snr.push({
                    type: 'scatter',
                    x: [-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
                    y: (Array(17).fill((val95snr).toExponential(2))),

                    hovertemplate: "%{text}: %{y} <extra></extra>",
                    text: (Array(17).fill("P(t) = 95%")),
                    mode: 'markers',
                    marker: {
                        size: 1,
                        opacity: 0,
                        color: "blue",
                        symbol: "triangle-down"
                    },

                })
                /* data_snr.push({
                    type: 'scatter',
                    x: [-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],
                    y: (Array(17).fill((val68snr).toExponential(2))),

                    hovertemplate: "%{text}: %{y} <extra></extra>",
                    text: (Array(17).fill("P(t) = 68%")),
                    mode: 'markers',
                    marker: {
                        size: 1,
                        opacity: 0,
                        color: "lightblue",
                        symbol: "triangle-down"
                    },


                }) */
                data_snr.push({
                    type: 'scatter',
                    x: Array(1).fill(0),
                    y: [math.mean(all_snr).toExponential(2)],
                    hovertemplate: "Ref. Mean: %{y} <extra></extra>",

                    mode: 'markers',
                    marker: {
                        size: 15,
                        color: "white",
                        symbol: "circle",
                        line: {
                            color: "blue",
                            width: 3
                        }
                    },


                })
                nonQCScore = []
                nonQCColors = []
                nonQCSymbols = []
                for (uuu = 0; uuu < all_snr.length; uuu++) {
                    nonQCScore.push(all_snr[uuu])
                    if (all_snr[uuu] > val95snr) {
                        nonQCColors.push("rgb(249, 8, 234)")
                        nonQCSymbols.push("x")
                        allDQFails.push(true)
                    } else {
                        nonQCColors.push("black")
                        nonQCSymbols.push("x")
                        allDQFails.push(false)
                    }
                }


                data_snr.push({
                    type: 'scatter',
                    x: Array(x.length).fill(0),
                    y: nonQCScore,
                    hovertemplate: "%{text}: %{y} <extra></extra>",
                    text: x,
                    mode: 'markers',
                    marker: {
                        size: 8,
                        color: nonQCColors,
                        symbol: nonQCSymbols,
                    },


                })

                //normal dist curve for DQ plot

                max_snr=math.mean(all_snr)+(((val95snr-math.mean(all_snr))/1.69)*3)
                //min_snr=Math.floor(math.min(testSetsnr)*100)/100
                min_snr=math.mean(all_snr)-(((val95snr-math.mean(all_snr))/1.69)*3)
                snr_diff=max_snr-min_snr
                normal_curvex=[]
                normal_curvey=[]
                normal_curvex_high=[]
                normal_curvey_high=[]
                for (let r=0;r<100;r++){
                    let normvaly=min_snr+((snr_diff/100)*r)
                    let normvalx=jStat.normal.pdf(normvaly, math.mean(all_snr), (val95snr-math.mean(all_snr))/1.69)
                    //let normvalx=jStat.studentt.pdf(normvaly, refSetsnr.length)
                    //normvalx=normvalx*math.std(refSetsnr)+math.mean(refSetsnr)
                    if(normvaly<val95snr){
                        normal_curvey.push(normvaly)
                        normal_curvex.push(normvalx)
                    }else{
                        normal_curvey_high.push(normvaly)
                        normal_curvex_high.push(normvalx)
                    }
                    
                }

                normal_curvey_high.unshift(normal_curvey[normal_curvey.length-1])
                normal_curvex_high.unshift(normal_curvex[normal_curvey.length-1])

                normal_curvey_high.unshift(normal_curvey[normal_curvey.length-1])
                normal_curvex_high.unshift(math.min(normal_curvex_high))

                normal_curvey.push(normal_curvey[normal_curvey.length-1])
                normal_curvex.push(math.min(normal_curvex))

                //normal_curvex=math.multiply(math.divide(normal_curvex, math.max(normal_curvex)), 0.8)
                if(max_snr>math.max(all_snr) && min_snr<math.min(all_snr)){
                    layoutsnr.yaxis.range=[min_snr,max_snr]
                }else if(max_snr>math.max(all_snr) && min_snr>math.min(all_snr)){
                    layoutsnr.yaxis.range=[math.min(all_snr)-snr_diff*0.05,max_snr]
                }else if(max_snr<math.max(all_snr) && min_snr<math.min(all_snr)){
                    layoutsnr.yaxis.range=[min_snr,math.max(all_snr)+snr_diff*0.05]
                }else{
                    layoutsnr.yaxis.range=[math.min(all_snr)-snr_diff*0.05,math.max(all_snr)+snr_diff*0.05]
                }
                //layoutsnr.yaxis.range=[min_snr,max_snr]

                data_snr.push({
                    type: 'line',
                    x: normal_curvex,
                    y: normal_curvey,
                    xaxis:"x2",
                    fill: 'tozeroy',
                    line:{
                        color:"lightblue",
                    },
                    hoverinfo:'skip'


                })
                data_snr.push({
                    type: 'line',
                    x: normal_curvex_high,
                    y: normal_curvey_high,
                    xaxis:"x2",
                    fill: 'toself',
                    line:{
                        color:"magenta",
                    },
                    hoverinfo:'skip'


                })


                snr_shapes = []

                /* snr_shapes.push(
                    {
                        type: 'line',
                        xref: 'paper',
                        x0: 0,
                        y0: val68snr,
                        x1: 1,
                        y1: val68snr,
                        line: {
                            color: 'lightblue',
                            width: 4,
                            dash: 'dot'
                        },
                        layer: "below"
                    }
                ) */

                snr_shapes.push(
                    {
                        type: 'line',
                        xref: 'paper',
                        x0: 0,
                        y0: val95snr,
                        x1: 1,
                        y1: val95snr,
                        line: {
                            color: 'magenta',
                            width: 3,
                            dash: 'dot'
                        },
                        layer: "below"
                    }
                )

                layoutsnr.shapes = snr_shapes
            }


            if (qcmode) {
                document.getElementById("nonQC").setAttribute('style', "display:none")
                document.getElementById("QC1").style.display = null
                document.getElementById("QC2").style.display = null

                if (passFlagFail.length > 0) {
                    failCount = 0;
                    passCount = 0;
                    flagCount = 0;
                    for (let fff = 0; fff < passFlagFail.length; fff++) {
                        if (passFlagFail[fff] == "fail") {
                            failCount++
                        } else if (passFlagFail[fff] == "pass") {
                            passCount++
                        } else if (passFlagFail[fff] == "flag") {
                            flagCount++
                        }

                    }
                    document.getElementById("failcount").innerHTML = "" + math.round(failCount / passFlagFail.length * 100) + "%"
                    document.getElementById("failcountSimp").innerHTML = "" + math.round(failCount / passFlagFail.length * 100) + "%"
                    document.getElementById("passcount").innerHTML = "" + math.round(passCount / passFlagFail.length * 100) + "%"
                    document.getElementById("passcountSimp").innerHTML = "" + math.round(passCount / passFlagFail.length * 100) + "%"
                    document.getElementById("flagcount").innerHTML = "" + math.round(flagCount / passFlagFail.length * 100) + "%"
                    document.getElementById("flagcountSimp").innerHTML = "" + math.round(flagCount / passFlagFail.length * 100) + "%"
                } else {
                    document.getElementById("failcount").innerHTML = "---%"
                    document.getElementById("failcountSimp").innerHTML = "---%"
                    document.getElementById("passcount").innerHTML = "---%"
                    document.getElementById("passcountSimp").innerHTML = "---%"
                    document.getElementById("flagcount").innerHTML = "---%"
                    document.getElementById("flagcountSimp").innerHTML = "---%"
                }


                if (all_zscores.length > 0) {
                    new_score = []
                    for (fff = 0; fff < all_zscores.length; fff++) {

                        new_score.push(all_zscores[fff])

                    }
                    new_score_final = Math.round((math.mean(new_score)))
                    document.getElementById("scoreBallVs").setAttribute('style', "background-color:" + colorBall[parseInt((1000 - new_score_final) / 10)])
                    document.getElementById("overallScoreVs").innerHTML = "" + new_score_final


                    document.getElementById("scoreBallRef").setAttribute('style', "display:none")

                } else {
                    document.getElementById("scoreBallVs").setAttribute('style', "background-color:#bbb")
                    document.getElementById("overallScoreVs").innerHTML = "XXXX"

                    document.getElementById("scoreBallRef").setAttribute('style', "display:none")

                }
                if (refSetActive.length > 1) {
                    document.getElementById("overallScoreRef").innerHTML = "<td><i>Av. Spectral Difference</i></td><td>  " + val95_text + "</td>"
                    document.getElementById("overallScoreSNR").innerHTML = "<td><i>Standard Error</i></td><td>  " + val95snr_text + "</td>"
                } else {
                    document.getElementById("overallScoreRef").innerHTML = "<td><i>Av. Spectral Difference</i></td><td>XXXX </td>"
                    document.getElementById("overallScoreSNR").innerHTML = "<td><i>Standard Error</i></td><td>XXXX </td>"
                }


            } else {
                document.getElementById("nonQC").style.display = null
                document.getElementById("QC1").style.display = null
                document.getElementById("QC2").setAttribute('style', "display:none")

                if (passFlagFail.length > 0) {
                    failCount = 0;
                    passCount = 0;
                    flagCount = 0;
                    for (let fff = 0; fff < passFlagFail.length; fff++) {
                        if (passFlagFail[fff] == "fail") {
                            failCount++
                        } else if (passFlagFail[fff] == "pass") {
                            passCount++
                        } else if (passFlagFail[fff] == "flag") {
                            flagCount++
                        }

                    }
                    document.getElementById("failcount").innerHTML = "" + math.round(failCount / passFlagFail.length * 100) + "%"
                    document.getElementById("failcountSimp").innerHTML = "" + math.round(failCount / passFlagFail.length * 100) + "%"
                    document.getElementById("passcount").innerHTML = "" + math.round(passCount / passFlagFail.length * 100) + "%"
                    document.getElementById("passcountSimp").innerHTML = "" + math.round(passCount / passFlagFail.length * 100) + "%"
                    document.getElementById("flagcount").innerHTML = "" + math.round(flagCount / passFlagFail.length * 100) + "%"
                    document.getElementById("flagcountSimp").innerHTML = "" + math.round(flagCount / passFlagFail.length * 100) + "%"
                } else {
                    document.getElementById("failcount").innerHTML = "---%"
                    document.getElementById("failcountSimp").innerHTML = "---%"
                    document.getElementById("passcount").innerHTML = "---%"
                    document.getElementById("passcountSimp").innerHTML = "---%"
                    document.getElementById("flagcount").innerHTML = "---%"
                    document.getElementById("flagcountSimp").innerHTML = "---%"
                }


            }
            if (qcmode) {
                if (refScore.length > 1) {
                    console.log("more than 2")
                    document.getElementById('plotly-divsig').style.display = null
                    document.getElementById('plotly-divsig-S').style.display = null
                    Plotly.react('plotly-divsig', data_sig, layoutsig, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                    Plotly.react('plotly-divsig-S', data_sig, layoutsig, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                    document.getElementById('plotly-divsnr').style.display = null
                    document.getElementById('plotly-divsnr-S').style.display = null
                    Plotly.react('plotly-divsnr', data_snr, layoutsnr, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                    Plotly.react('plotly-divsnr-S', data_snr, layoutsnr, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                } else {
                    console.log("less than 2")

                    document.getElementById('plotly-divsig-S').setAttribute('style', "display:none")
                    document.getElementById('plotly-divsig').setAttribute('style', "display:none")
                    document.getElementById('plotly-divsnr').setAttribute('style', "display:none")
                    document.getElementById('plotly-divsnr-S').setAttribute('style', "display:none")


                }
            } else {
                document.getElementById('plotly-divsig').style.display = null
                document.getElementById('plotly-divsig-S').style.display = null
                Plotly.react('plotly-divsig', data_sig, layoutsig, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                Plotly.react('plotly-divsig-S', data_sig, layoutsig, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                document.getElementById('plotly-divsnr').style.display = null
                document.getElementById('plotly-divsnr-S').style.display = null
                Plotly.react('plotly-divsnr', data_snr, layoutsnr, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });
                Plotly.react('plotly-divsnr-S', data_snr, layoutsnr, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });

            }

        }


        if (document.getElementById("collapseThree").className != "collapse show") {
            document.getElementById("collapseThree").className = "collapse show"
        }

        return (data_hm)
    }
    else {

        data_l2 = []
        data_l2.push({
            x: [],
            y: [],


            mode: "lines",
            name: "Premium",
            type: "scatter",
            hoverinfo: "name+x",


        });

        plot2 = Plotly.react('plotly-div2', data_l2, layout2, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });

        score = "NA"
        document.getElementById("score").innerHTML = "NA% difference<br> <small><small>Add data above</small></small>"

        data_overlap = [{
            type: 'scatter',
            fill: 'tozeroy',
            x: [],
            y: [],
            hoverinfo: 'x+y',
            line: { color: 'rgb(247, 43, 43)' }

        }]

        layoutOL.yaxis.range = [0, 1]

        document.getElementById("failcount").innerHTML = "---%"
        document.getElementById("failcountSimp").innerHTML = "---%"
        document.getElementById("passcount").innerHTML = "---%"
        document.getElementById("passcountSimp").innerHTML = "---%"
        document.getElementById("flagcount").innerHTML = "---%"
        document.getElementById("flagcountSimp").innerHTML = "---%"
        document.getElementById('plotly-divsig-S').setAttribute('style', "display:none")
        document.getElementById('plotly-divsig').setAttribute('style', "display:none")
        document.getElementById('plotly-divsnr').setAttribute('style', "display:none")
        document.getElementById('plotly-divsnr-S').setAttribute('style', "display:none")

        data_hm = [
            {
                z: [],
                x: [],
                y: [],
                type: 'heatmap',
                colorscale: [


                    ['0.0', 'rgb(19, 214, 45)'],
                    ['0.25', 'rgb(240, 247, 43)'],
                    ['0.5', 'rgb(247, 233, 44)'],
                    ['0.75', 'rgb(247, 103, 37)'],
                    ['1.0', 'rgb(247, 43, 43)']
                ],//mode["RMSD"].colorScale,
                zmin: 0,
                zmax: 1
            }
        ];

        Plotly.react('plotly-divHm', data_hm, layoutHM, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })


        data_dev = [{
            type: 'scatter',
            fill: 'tozeroy',
            x: [],
            y: [],
            hoverinfo: 'x+y',
            line: { color: 'rgb(247, 43, 43)' }

        }]

        layoutDEV.yaxis.range = [0, 1]


        data_hm2 = [
            {
                z: [],
                x: [],
                y: [],
                type: 'heatmap',
                colorscale: [


                    ['0.0', 'rgb(19, 214, 45)'],
                    ['0.25', 'rgb(240, 247, 43)'],
                    ['0.5', 'rgb(247, 233, 44)'],
                    ['0.75', 'rgb(247, 103, 37)'],
                    ['1.0', 'rgb(247, 43, 43)']
                ],//mode["RMSD"].colorScale,
                zmin: 0,
                zmax: 1
            }
        ];

        if (document.getElementById("collapseThree").className != "collapse") {
            document.getElementById("collapseThree").className = "collapse"
        }
    }

    if (Object.keys(batches).length - inactive.length < 2 || refSetActive.length < 3) {
        if (qcmode) {
            document.getElementById("nonQC").setAttribute('style', "display:none")
            document.getElementById("QC1").style.display = null
            document.getElementById("QC2").style.display = null

            document.getElementById("scoreBallRef").setAttribute('style', "display:none")
            document.getElementById("overallScoreRef").innerHTML = "<td><i>Av. Spectral Difference</i></td><td>XXXX</td>"

            document.getElementById("scoreBallVs").setAttribute('style', "background-color:#bbb")
            document.getElementById("overallScoreVs").innerHTML = "XXXX"

        } else {
            document.getElementById("nonQC").style.display = null
            document.getElementById("QC1").setAttribute('style', "display:none")
            document.getElementById("QC2").setAttribute('style', "display:none")
            document.getElementById("scoreBall").setAttribute('style', "background-color:#bbb")
            document.getElementById("overallScore").innerHTML = "XXXX"

        }

    } else {

        refScore = []
        vsScore = []
        for (ppp = 0; ppp < pw_av_zscore.length; ppp++) {
            if (refSetInd.includes(ppp)) {
                refScore.push(pw_av_zscore[ppp])
            } else {
                vsScore.push(pw_av_zscore[ppp])
            }
        }


        if (qcmode) {
            document.getElementById("nonQC").setAttribute('style', "display:none")
            document.getElementById("QC1").style.display = null
            document.getElementById("QC2").style.display = null

            document.getElementById("scoreBallRef").setAttribute('style', "display:none")
            document.getElementById("overallScoreRef").innerHTML = "" + Math.round(lower) + "+"

            if (vsScore.length > 0) {
                document.getElementById("scoreBallVs").setAttribute('style', "background-color:" + colorBall[parseInt(Math.round(1000 - math.mean(vsScore)) / 10)])
                document.getElementById("overallScoreVs").innerHTML = "" + Math.round(((math.mean(vsScore))))
            } else {
                document.getElementById("scoreBallVs").setAttribute('style', "background-color:#bbb")
                document.getElementById("overallScoreVs").innerHTML = "XXXX"
            }


        } else {
            document.getElementById("nonQC").style.display = null
            document.getElementById("QC1").setAttribute('style', "display:none")
            document.getElementById("QC2").setAttribute('style', "display:none")

            score = 1000 - math.mean(pw_av_zscore)
            document.getElementById("scoreBall").setAttribute('style', "background-color:" + colorBall[parseInt(Math.round(score) / 10)])
            document.getElementById("overallScore").innerHTML = "" + Math.round((1000 - (score)))

        }
    }

}

function zscoreSingle(m, d, sd) {
    return ((d - m) / sd)
}

function tscoreSingle(m, d, sd, n) {
    return ((m - d) / (sd / Math.sqrt(n)))
}

function tscoreTwoSample(m1, m2, s1, s2, n1, n2) {
    let t = (m1 - m2 - (-equivMult * s1)) / math.sqrt((s1 ** 2 / n1) + (s2 ** 2 / n2))
    return (t)
}

function twoSampDOF(s1, s2, n1, n2) {
    s1n1 = s1 ** 2 / n1
    s2n2 = s2 ** 2 / n2
    let top = (s1n1 + s2n2) ** 2
    let bottom = s1n1 ** 2 / (n1 - 1) + s2n2 ** 2 / (n2 - 1)
    let dof = top / bottom
    return (dof)
}




document.getElementById('fileinput').addEventListener('change', readMultipleFiles, false);
document.getElementById('bufferinput').addEventListener('change', readBufferFiles, false);

var data = {};



data[String(batchCount)] = {
    x: [],
    y: [],


    mode: "lines",
    name: "Premium",
    type: "scatter",
    hoverinfo: "name+x",

};
var data2 = {};



data2[String(batchCount)] = {
    x: [],
    y: [],


    mode: "lines",
    name: "Premium",
    type: "scatter",
    hoverinfo: "name+x",

};



var layout = {
    selectdirection: "h",
    dragmode: "zoom",
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 600,
    height: 300,
    margin: {
        t: 30,
        b: 0,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: false,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,
        mirror: true,

    },
    yaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,

        mirror: true,
    }

};

var layoutSimp = {
    selectdirection: "h",
    dragmode: "zoom",
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 600,
    height: 400,
    margin: {
        t: 30,
        b: 50,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,
        mirror: true,

    },
    yaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,

        mirror: true,
    }

};

var layoutOL = {
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 400,
    height: 50,

    margin: {
        t: 0,
        b: 0,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        autorange: false,
        gridcolor: "rgb(229,229,229)",
        showgrid: false,
        showline: false,
        mirror: true,
        showticklabels: false,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true


    },
    yaxis: {
        range: [0, 1],
        gridcolor: "rgb(229,229,229)",
        showgrid: false,
        showline: false,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(255,255,255)",

        zeroline: false,
        tickfont: {
            color: "rgb(255,255,255)"
        },
        fixedrange: true
    }

};

var layoutDEV = {
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 400,
    height: 250,

    margin: {
        t: 30,
        b: 50,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: false,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,


    },
    yaxis: {
        range: [0, 1],
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(255,255,255)",

        zeroline: false,
        /* tickfont:{
            color:"rgb(255,255,255)"
        } */
    }

};

var layoutPre = {

    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 400,
    height: 250,
    margin: {
        t: 30,
        b: 50,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,

    },
    yaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true
    },
    yaxis2: {
        range: [2.5, 6],
        zeroline: false,
        showgrid: false,
        showline: false,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        overlaying: 'y',
        side: 'right',
        ticks: '',
        showticklabels: false
    }

};
var layoutOutliers = {

    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 400,
    height: 300,
    margin: {
        t: 30,
        b: 100,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    xaxis: {
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,
        tickangle: 80,

    },
    yaxis: {

        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true
    },



};



var layout2 = {
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 600,
    height: 130,
    margin: {
        t: 0,
        b: 50,
        r: 30,
        l: 50
    },
    hovermode: 'closest',
    showlegend: false,
    dragmode: 'pan',
    xaxis: {
        gridcolor: "rgb(229,229,229)",

        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,
        fixedrange: true
    },
    yaxis: {

        rangemode: "nonnegative",
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: true,
        fixedrange: true
    }

};

var layoutsig = {
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 900,
    height: 400,
    margin: {
        t: 30,
        b: 50,
        r: 5,
        l: 50
    },
    hovermode: 'closest',
    hoverlabel: {
        bgcolor: "white",
    },
    showlegend: false,
    dragmode: 'pan',
    xaxis: {
        gridcolor: "rgb(229,229,229)",

        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true,


    },
    yaxis: {

        tickfont: { size: 10 },

        exponentformat: "power",
        showexponent: "all",
        rangemode: "nonnegative",
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true
    }

};

var layoutsigSimp = {
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 1200,
    height: 300,
    margin: {
        t: 30,
        b: 50,
        r: 5,
        l: 50
    },
    hovermode: 'closest',
    hoverlabel: {
        bgcolor: "white",
    },
    showlegend: false,
    dragmode: 'pan',
    xaxis: {
        gridcolor: "rgb(229,229,229)",

        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true,


    },
    yaxis: {

        tickfont: { size: 10 },

        exponentformat: "power",
        showexponent: "all",
        rangemode: "nonnegative",
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true
    }

};

var layoutsnr = {
    colorway: colScheme,
    paper_bgcolor: "rgb(255,255,255)",
    plot_bgcolor: "rgb(255,255,255)",
    autosize: false,
    width: 300,
    height: 400,
    margin: {
        t: 30,
        b: 50,
        r: 100,
        l: 100
    },
    hovermode: 'closest',
    hoverlabel: {
        bgcolor: "white",
    },
    showlegend: false,
    dragmode: 'pan',
    xaxis: {
        gridcolor: "rgb(229,229,229)",

        showgrid: false,
        showline: true,
        mirror: true,
        showticklabels: false,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true,

        ticks: "",
    },
    yaxis: {
        tickfont: { size: 10 },

        exponentformat: "power",
        showexponent: "all",

        rangemode: "nonnegative",
        gridcolor: "rgb(229,229,229)",
        showgrid: true,
        showline: true,
        mirror: true,
        showticklabels: true,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true
    },
    xaxis2: {
        tickfont: { size: 10 },

        exponentformat: "power",
        showexponent: "all",
        overlaying:"x",
        anchor:"y",
        rangemode: "nonnegative",
        gridcolor: "rgb(229,229,229)",
        showgrid: false,
        showline: false,
        mirror: false,
        showticklabels: false,
        tickcolor: "rgb(127,127,127)",
        ticks: "outside",
        zeroline: false,
        fixedrange: true
    }

};

var layoutHM = {
    autosize: false,
    width: 500,
    height: 425,
    margin: {
        t: 40,
        b: 40,
        r: 40,
        l: 40
    },
    xaxis: { side: "top", fixedrange: true },
    yaxis: { fixedrange: true },
    automargin: false

}
var layoutHMTr = {
    autosize: true,
    width: 400,
    height: 400,
    /* margin:{
        t:30,
        b:50,
        r:30,
        l:100
    }, */
    xaxis: { automargin: true },
    yaxis: { automargin: true, tickangle: 45 },
    title: "File-Magnitude O/E"

}

var data_hm = [
    {
        z: [],
        x: [],
        y: [],
        type: 'heatmap',
        colorscale: [


            ['0.0', 'rgb(19, 214, 45)'],
            ['0.25', 'rgb(240, 247, 43)'],
            ['0.5', 'rgb(247, 233, 44)'],
            ['0.75', 'rgb(247, 103, 37)'],
            ['1.0', 'rgb(247, 43, 43)']
        ],//mode["RMSD"].colorScale,
        zmin: 0,
        zmax: 1
    }
];

var data_dev = [
    {
        z: [],
        x: [],
        y: [],
        type: 'heatmap',
        colorscale: [


            ['0.0', 'rgb(19, 214, 45)'],
            ['0.15', 'rgb(240, 247, 43)'],
            ['0.4', 'rgb(247, 233, 44)'],
            ['0.6', 'rgb(247, 103, 37)'],
            ['1.0', 'rgb(247, 43, 43)']
        ],
        zmin: 0,
        zmax: 1
    }
];

data_overlap = [{
    type: 'scatter',
    fill: 'tozeroy',
    x: [],
    y: [],
    hoverinfo: 'x+y',
    line: { color: 'rgb(247, 43, 43)' }

}]


Plotly.plot('plotly-divHm', data_hm, layoutHM, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })

var data_l = [];
data_l2 = [];

Object.keys(data).forEach(function (key, index) {



    data_l.push(data[key])
    data_l2.push(data2[key])

});

plot1 = Plotly.plot('plotly-div', data_l, layout, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
plot1S = Plotly.plot('plotly-div-S', data_l, layoutSimp, { modeBarButtons: cd_mb, modeBarButtonsToRemove: removeOptions, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true })
plot2 = Plotly.plot('plotly-div2', data_l2, layout2, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });


var myPlot = document.getElementById('plotly-div')
var myPlot2 = document.getElementById('plotly-div2')
var myPlotHm = document.getElementById('plotly-divHm')


myPlot.on('plotly_relayout', function (data) {

    x1 = data_l2[0].x.indexOf(math.round(myPlot.layout.xaxis.range[0]))
    x2 = data_l2[0].x.indexOf(math.round(myPlot.layout.xaxis.range[1]))
    if (x2 == -1) {
        x2 = 0
    }
    if (x1 == -1) {
        x1 = data_l2[0].x.length - 1
    }

    maxy = 0;
    for (ii = 0; ii < data_l2.length; ii++) {
        if (data_l2[ii].y.slice(x2, x1 + 1).length > 0) {
            maxy_tmp = math.max(data_l2[ii].y.slice(x2, x1 + 1))

            if (maxy_tmp > maxy) {

                maxy = maxy_tmp + 0

            }
        }
        if (data_l2[ii].y.slice(x2 + data_l2[0].x.length, x1 + data_l2[0].x.length + 1).length > 0) {
            maxy_tmp = math.max(data_l2[ii].y.slice(x2 + data_l2[0].x.length, x1 + data_l2[0].x.length + 1))

            if (maxy_tmp > maxy) {

                maxy = maxy_tmp + 0

            }
        }

    }


    newUpdate1 = {
        'xaxis.range': myPlot.layout.xaxis.range,
        'yaxis.range': [0, maxDiff],
    }
    newUpdate2 = {
        'xaxis.range': myPlot.layout.xaxis.range,

    }

    Plotly.relayout('plotly-div2', newUpdate1, { modeBarButtons: gen_mb, displaylogo: false, doubleClick: false, showAxisDragHandles: false, displayModeBar: true });

});

document.getElementById("downloadSession").addEventListener("click", function () { downloadDCS(batches) })

        
</script>

        
        
    </body>
</html>
